---
title: MIT 6.S081
date: 2023-03-16 21:37:59
tags:

---

# MIT 6.S081

## 理论部分

### 陷阱和系统调用

* **陷阱机制**：内核通过对**特定控制寄存器**进行写操作，CPU利用这些寄存器的信息处理陷阱
  * **特定控制寄存器**
    * *STVEC*：保存陷阱处理代码的地址
    * *SEPC*：保存进入陷阱前的PC
    * *SCAUSE*：保存陷阱的类型
    * *SSCRATCH*：
    * *SSTATUS*：分为SIE位、SPP位，前者控制中断使能，后者表示陷阱来自内核态还是用户态
  * **以上这些特定控制寄存器只能在特权级进行修改**
  * **大致流程**
    * *禁用中断(SIE位清零)*
    * *保存PC至SEPC*
    * *保存发生陷阱时的特权级别(SPP位)*
    * *设置scause(反应陷阱的原因)*
    * *设置CPU到内核态*
    * *将STVEC复制到PC*
    * *执行新PC*
  * **注意事项**：目前仅仅在用户态做了很少的工作，即没有切换页表，也没有切换内核堆栈，更没有保存任何寄存器。
* **来自用户态的陷阱**
  * **高视角下用户态陷阱的执行过程**：*uservec*$\to$*usertrap*$\to$*usertrapset*$\to$*userret*
  * **蹦床页面**：由于最初并未对页表进行切换，因此**STEVC**必须同时在**内核页表和用户进程页表**中进行**有效映射**
    * *该页面被映射到每个进程的地址空间的最高地址处*
  * **保存现场**：保存进入陷阱前的32个寄存器状态，此时需要**SSCRATCH**辅助保存，**因为此时没有空闲通用寄存器**
    * 将$a_0$与**SSCRATCH**交换数据，$a_0$在交换之后内部存储的是Trampframe的基址
  * **Trapframe**
    * *用于存储进入陷阱前状态以及返回值，此页面由内核维护，用户进程不能访问*
    * *存放着当前进程的内核堆栈地址*
    * *存放着内核页表的地址*
    * *CPU标示号*
    * *陷阱处理C函数地址*
  * **usertrap**：确定造成陷阱的原因，对陷阱处理，并返回

## 实验部分

### Lab 3

### 检测被访问过的页面

* **背景**：一些垃圾回收机制如果能够获取页面是否被访问的信息，将能够提高效率。
* **目的**：实现检测页表访问位并将结果返回到用户态
* **前提知识**
  * RISC-V硬件处理TLB缺失时，将新的虚拟地址载入时，会将相应的页面访问位置位
* **具体工作**
  * 代码实现在**kernel/sysproc.c**中的**sys_pgaccess**()，参数如下
    * 第一个要检查的用户页面的虚拟地址
    * 将要检查页面的数量
    * 用于返回掩码结果的用户空间地址
  * 使用**argaddr()**和**argint()**解析参数
  * 最好在内核使用一个临时的缓冲区保存要输出的位掩码，利用**copyout**()输出
  * 可以设置扫描页面数量的上限
  * 使用walk()来找到正确的PTEs
  * 需要在**kernel/riscv.h**中定义**PTE_A**
  * 确保检查**PTE_A**后，将其清零。否则无法判断在上次检查之后该页面有没有再次被访问
  * 使用**vmprint()**来帮助debug
* **代码**
  * 
