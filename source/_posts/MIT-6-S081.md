---
title: MIT 6.S081
date: 2023-03-16 21:37:59
tags:

---

# MIT 6.S081

## 配置问题

### **本地环境**

* **设备**：*MacBook Air 2020 ( m1 芯片 )*
* **编译器**：*Apple clang version 14.0.0 (clang-1400.0.29.202)*

### 问题清单

* **无穷递归**
  * **问题描述**：*error: infinite recursion detected [-Werror=infinite-recursion]*
  * **解决方法**：在**sh.c**中**runcmd**函数签名上添加*\__attribute__((noreturn))*

## 理论部分

### 陷阱和系统调用

* **陷阱机制**：内核通过对**特定控制寄存器**进行写操作，CPU利用这些寄存器的信息处理陷阱
  * **特定控制寄存器**
    * *STVEC*：保存陷阱处理代码的地址
    * *SEPC*：保存进入陷阱前的PC
    * *SCAUSE*：保存陷阱的类型
    * *SSCRATCH*：
    * *SSTATUS*：分为SIE位、SPP位，前者控制中断使能，后者表示陷阱来自内核态还是用户态
  * **以上这些特定控制寄存器只能在特权级进行修改**
  * **大致流程**
    * *禁用中断(SIE位清零)*
    * *保存PC至SEPC*
    * *保存发生陷阱时的特权级别(SPP位)*
    * *设置scause(反应陷阱的原因)*
    * *设置CPU到内核态*
    * *将STVEC复制到PC*
    * *执行新PC*
  * **注意事项**：目前仅仅在用户态做了很少的工作，即没有切换页表，也没有切换内核堆栈，更没有保存任何寄存器。
* **来自用户态的陷阱**
  * **高视角下用户态陷阱的执行过程**：*uservec*$\to$*usertrap*$\to$*usertrapset*$\to$*userret*
  * **蹦床页面**：由于最初并未对页表进行切换，因此**STEVC**必须同时在**内核页表和用户进程页表**中进行**有效映射**
    * *该页面被映射到每个进程的地址空间的最高地址处*
  * **保存现场**：保存进入陷阱前的32个寄存器状态，此时需要**SSCRATCH**辅助保存，**因为此时没有空闲通用寄存器**
    * 将$a_0$与**SSCRATCH**交换数据，$a_0$在交换之后内部存储的是Trampframe的基址
  * **TRAMPFRAME**
    * *用于存储进入陷阱前状态以及返回值，此页面由内核维护，用户进程不能访问*
    * *存放着当前进程的内核堆栈地址*
    * *存放着内核页表的地址*
    * *CPU标示号*
    * *陷阱处理C函数地址*
  * **USERTRAP**：确定造成陷阱的原因，对陷阱处理，并返回
    * 首先将**STVEC**更改为**kernelvec**，这样在内核中发生的**TRAP**就是被kernelvec处理
    * 然后保存**SEPC**，因为**TRAP**过程中可能会调用**yield**（时钟中断）函数切换到另外一个进程的内核线程，该线程可能会返回用户空间，这个过程将会改变**SEPC**的值。（==不太懂==）
    * 根据**TRAP**的不同类型分别处理
    * **将程序计数器加4**：当前的程序计数器指向ecall，我们希望**TRAP**执行完后执行ecall的下一条指令
    * 最后检查该设备中断是否是时钟中断，若是则执行**yield**函数放弃CPU
  * **返回用户空间**
    * **usertrapret**：配置**TRAPFRAME**以处理下一次来自用户空间的**TRAP**。包括配置**STVEC**为**uservec**，配置**SEPC**为之前的程序计数器，配置**uservec**依赖的各种参数(*kernel_pgtbl...*)，最后调用**userret**
    * **userret**：接收**TRAPFRAME**和**PGTBL**参数。首先将**TRAPFRAME**中保存的$a_0$与**SSCRATCH**交换，交换后$a_0$存储的是**TRAPFRAME**的地址，以其为基址将**TRAPFRAME**中保存的状态恢复到CPU中的寄存器中。最后$a_0$与**SSCRATCH**交换，以便下一次**TRAP**发生时，**SSCRATCH**保存着该进程的**TRAPFRAME**的地址
* **来自内核态的陷阱**
  * **保存现场**：kernelvec首先将寄存器状态压入该线程的内核堆栈，以便当**TRAP**返回的时候从堆栈恢复现场，接着调用**kerneltrap**
  * **陷阱类型**：来自内核态的陷阱的类型分为**设备中断**和**异常**。若是设备中断，则会检查并执行相应的例程。若是异常，操作系统则会崩溃
    * **定时器中断**是设备中断中比较特殊的存在。当前线程会放弃CPU，在将来某个时间点通过堆栈恢复状态继续执行。
  
  * **返回**：复制**SEPC**到**PC**，并恢复现场。
  

### 缺页异常



## 实验部分

### Page Tables

#### 检测被访问过的页面

* **背景**：一些垃圾回收机制如果能够获取页面是否被访问的信息，将能够提高效率。
* **目的**：实现检测页表访问位并将结果返回到用户态
* **预备知识**
  * RISC-V硬件处理TLB缺失时，将新的虚拟地址载入时，会将相应的页面访问位置位
* **任务**
  * 代码实现在**kernel/sysproc.c**中的**sys_pgaccess**()，参数如下
    * 第一个要检查的用户页面的虚拟地址
    * 将要检查页面的数量
    * 用于返回掩码结果的用户空间地址
  * 使用**argaddr()**和**argint()**解析参数
  * 最好在内核使用一个临时的缓冲区保存要输出的位掩码，利用**copyout**()输出
  * 可以设置扫描页面数量的上限
  * 使用walk()来找到正确的PTEs
  * 需要在**kernel/riscv.h**中定义**PTE_A**
  * 确保检查**PTE_A**后，将其清零。否则无法判断在上次检查之后该页面有没有再次被访问
  * 使用**vmprint()**来帮助debug
* **代码**

### Traps

*帧指针、栈指针是函数调用的灵魂，栈指针负责为局部变量和参数分配空间，帧指针扮演寻找变量和参数的基石*

*内核堆栈和进程堆栈没有联系，只是他们都和进程一一对应*

#### RISC-V汇编初识

* **目的**：了解RISC-V中的汇编指令

* **预备知识**：汇编语言

* **任务**
  * 编译**fs.img**，阅读**call.asm**中的**g、f、main**函数。回答以下问题并将答案编辑在answers-traps.txt文件之中
    * 哪些寄存器保存传递给函数的参数，例如：当main函数调用printf函数时，哪个寄存器保存了13？
    
      $a_0,a_1,a_2$，其中调用printf时，$a_2$寄存器保存了13
    
    * 在main函数的汇编码中，哪里调用了f，g这两个函数
    
    * 函数 printf 位于什么地址？
    
      0x616，在RISCV指令中，auipc指令一般结合其他跳转指令来执行，因为在RISCV指令中无法表示32位的立即数，因此需要用auipc指令将一个20位立即数左移12位加上PC，存储在目的寄存器中。然后再由接下来的跳转指令用12位立即数填充低12位，最后实现跳转到PC附近的32位地址。这里的计算就是：$0x30+1510_{(10)}=0x616$
    
    * 在 jalr 到 main 中的 printf 之后，寄存器 ra 中的值是什么？
    
      38，即当前地址+4
    
    * 运行以下代码
    
      ```C
      unsigned int i = 0x00646c72;
      printf("H%x Wo%s", 57616, &i);
      ```
    
      请问输出是什么？(这段代码的输出依赖于RISC-V的小端模式)。若这段代码运行在大端模式的机器中，要使输出相同，应该给$\;i\;$赋什么值？需要将57616改为其他值么？
    
      输出是`Hell0 World`，不用更改`57616`，只需要将`0x00646c72`改为`0x726c6400`
    
    * 在这行代码中
    
      ```C
      printf("x=%d y=%d", 3);
      ```
    
      $y=\;$后面会出现什么数字？(*提示：这个数据不是某个特定的数字*) 为什么会出现这种情况？
    
      y后面的数字是随机的数字，取决于从栈帧中取到a2的垃圾数据

#### 堆栈回溯

* **背景**：在调试过程中，如果知道在出错点处的堆栈中存在哪些没有返回的函数调用是非常有帮助的

* **任务**
  * 在`kernel/printf.c`中实现`backtrace()`函数，并在`sys_sleep`中调用
  * 在`panic`函数中调用`backtrace`，以便在系统崩溃时了解相关信息
  
* **代码**
  
  * 修改`riscv.h`
  
    ```C
    // read the s0 register
    static inline uint64
    r_fp()
    {
      uint64 x;
      asm volatile("mv %0, s0" : "=r" (x) );
      return x;
    }
    ```
  
  * `backtrace()`
  
    ```C
    void
    backtrace(void)
    {
      printf("backtrace:\n");
      uint64 fp = r_fp();
      uint64 head = PGROUNDDOWN(fp);
      uint64 tail = PGROUNDUP(fp);
      uint64 ra;
    
      while((fp >= head) && fp <= tail){
        ra = *(uint64*)(fp - 8);
        fp = *(uint64*)(fp - 16);
        printf("%p\n", ra);
      }
    }
    ```
  
  * `panic(char* s)`
  
    ```C
    void
    panic(char *s)
    {
      pr.locking = 0;
      printf("panic: ");
      printf(s);
      printf("\n");
      backtrace();
      panicked = 1; // freeze uart output from other CPUs
      for(;;)
        ;
    }
    ```
  
  * `sys_sleep`
  
    ```C
    uint64
    sys_sleep(void)
    {
      int n;
      uint ticks0;
    
      if(argint(0, &n) < 0)
        return -1;
      acquire(&tickslock);
      ticks0 = ticks;
      while(ticks - ticks0 < n){
        if(myproc()->killed){
          release(&tickslock);
          return -1;
        }
        sleep(&ticks, &tickslock);
      }
      release(&tickslock);
      backtrace();
      return 0;
    }
    ```

#### 闹钟

* **背景**：计算密集型进程往往想知道自己消耗了多少时间，同时一些进程希望定期做某件任务

* **任务**

  * 实现一个**用户级中断**处理程序，`sigalarm(interval, handler)`
  * 调用`sigalarm(n, fn)`的函数每经过`n`个CPU时钟，`kernel`就会调用`fn`，当`fn`返回后，进程恢复继续执行。(*本质就是TRAP*)
  * 当应用调用`sigalarm(0,0)`时，`kernel`应该停止周期闹铃
  * 在`Makefile`中添加`alarmtest.c`，同时在`kernel`添加`sigalarm`和`sigturn`
  * `user/alarmtest.asm`或许对调试有所帮助

* **代码**

  * 修改`Makefile`

    ```makefile
    ifeq ($(LAB),traps)
    UPROGS += \
    	$U/_call\
    	$U/_bttest\
    	$U/_alarmtest
    endif
    ```

  * 修改`usys.pl`

    ```perl
    entry("sigalarm");
    entry("sigturn");
    ```

  * 修改`syscall.h`

    ```c
    #define SYS_sigalarm    22
    #define SYS_sigturn     23
    ```

  * 修改`syscall.c`

    ```C
    ...
    extern uint64 sys_sigalarm(void);
    extern uint64 sys_sigturn(void);
    
    static uint64 (*syscalls[])(void) = {
    	...
    	[SYS_sigalarm]  sys_sigalarm,
    	[SYS_sigturn]   sys_sigturn,
    }
    ```

  * 修改`sysproc.c`

    
