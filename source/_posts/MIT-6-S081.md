---
title: MIT 6.S081
tags: [操作系统，国外课程，系统学习]
categories: [技术主线，操作系统，MIT-6.S081]
poster:
  topic: 标题上方的小字
  headline: 大标题
  caption: 标题下方的小字
  color: 标题颜色
date: 2023-03-16 21:37:59
description: 计算机操作系统的入门教程
cover: 
banner:
---

# MIT 6.S081

## 配置问题

### **本地环境**

* **设备**：*MacBook Air 2020 ( m1 芯片 )*
* **编译器**：*Apple clang version 14.0.0 (clang-1400.0.29.202)*

### 问题清单

* **无穷递归**
  * **问题描述**：*error: infinite recursion detected [-Werror=infinite-recursion]*
  * **解决方法**：在**sh.c**中**runcmd**函数签名上添加*\__attribute__((noreturn))*

## 理论部分

### 陷阱和系统调用

* **陷阱机制**：内核通过对**特定控制寄存器**进行写操作，CPU利用这些寄存器的信息处理陷阱
  * **特定控制寄存器**
    * `STVEC`：保存陷阱处理代码的地址
    * `SEPC`：保存进入陷阱前的PC
    * `SCAUSE`：保存陷阱的类型
    * `SSCRATCH`：
    * `SSTATUS`：分为SIE位、SPP位，前者控制中断使能，后者表示陷阱来自内核态还是用户态
  * **以上这些特定控制寄存器只能在特权级进行修改**
  * **大致流程**
    * 禁用中断(SIE位清零)
    * 保存PC至SEPC
    * 保存发生陷阱时的特权级别(SPP位)
    * 设置scause(反应陷阱的原因)
    * 设置CPU到内核态
    * 将STVEC复制到PC
    * 执行新PC
  * **注意事项**：目前仅仅在用户态做了很少的工作，即没有切换页表，也没有切换内核堆栈，更没有保存任何寄存器。
  
* **来自用户态的陷阱**
  * **高视角下用户态陷阱的执行过程**：`uservec`$\to$`usertrap`$\to$`usertrapset`$\to$`userret`
  
  * **蹦床页面**：由于最初并未对页表进行切换，因此`STEVC`必须同时在**内核页表和用户进程页表**中进行**有效映射**
    * *该页面被映射到每个进程的地址空间的最高地址处*
    
  * **保存现场**：保存进入陷阱前的32个寄存器状态，此时需要`SSCRATCH`辅助保存，**因为此时没有空闲通用寄存器**
    * 将$a_0$与`SSCRATCH`交换数据，$a_0$在交换之后内部存储的是`Trampframe`的基址
    
  * `TRAMPFRAME`
    
    *映射到每个进程地址空间蹦床页面下方，并设置为特权级可访问*
    
    * 用于存储进入陷阱前状态以及返回值，此页面由内核维护，用户进程不能访问
    * 存放着当前进程的内核堆栈地址
    * 存放着内核页表的地址
    * CPU标示号
    * 陷阱处理C函数地址
    
  * `USERTRAP`：确定造成陷阱的原因，对陷阱处理，并返回
    * 首先将`STVEC`更改为`kernelvec`，这样在内核中发生的`TRAP`就是被`kernelvec`处理
    * 然后保存`SEPC`，因为`TRAP`过程中可能会调用`yield`（时钟中断）函数切换到另外一个进程的内核线程，该线程可能会返回用户空间，这个过程将会改变`SEPC`的值。
    * 根据`TRAP`的不同类型分别处理
    * **将程序计数器加4**：当前的程序计数器指向`ecall`，我们希望`TRAP`执行完后执行ecall的下一条指令
    * 最后检查该设备中断是否是时钟中断，若是则执行`yield`函数放弃CPU
    
  * **返回用户空间**
    * `usertrapret`：配置`TRAPFRAME`以处理下一次来自用户空间的`TRAP`。包括配置`STVEC`为`uservec`，配置`SEPC`为之前的程序计数器，配置`uservec`依赖的各种参数(*kernel_pgtbl...*)，最后调用`userret`
    * `userret`：接收`TRAPFRAME`和`PGTBL`参数。首先将`TRAPFRAME`中保存的$a_0$与`SSCRATCH`交换，交换后$a_0$存储的是`TRAPFRAME`的地址，以其为基址将`TRAPFRAME`中保存的状态恢复到CPU中的寄存器中。最后$a_0$与`SSCRATCH`交换，以便下一次`TRAP`发生时，`SSCRATCH`保存着该进程的`TRAPFRAME`的地址
  
* **来自内核态的陷阱**
  
  * **保存现场**：`kernelvec`首先将寄存器状态压入该线程的内核堆栈，以便当`TRAP`返回的时候从堆栈恢复现场，接着调用`kerneltrap`
  * **陷阱类型**：来自内核态的陷阱的类型分为**设备中断**和**异常**。若是设备中断，则会检查并执行相应的例程。若是异常，操作系统则会崩溃
    * **定时器中断**是设备中断中比较特殊的存在。当前线程会放弃CPU，在将来某个时间点通过堆栈恢复状态继续执行。
  
  * **返回**：复制`SEPC`到`PC`，并恢复现场。
  

### 缺页异常

*一种辅助实现懒加载的机制*

* **处理缺页异常**

  * **引发缺页异常的虚拟地址**：存储在`STVAL`寄存器中
  * **引发缺页异常的原因**：存储在`SCAUSE`寄存器中
  * **引发缺页异常的指令地址**：存储在`SEPC`寄存器中

  利用以上三个寄存器的信息，就能知道进入内核后如何处理缺页异常，并知道回到用户态时需要重新执行的指令的地址。

* **懒内存分配机制**：在进程申请内存的时候，并不立即分配内存并映射到该进程的地址空间，而是仅对该进程的栈顶指针进行修改，等到进程真正使用申请的内存时，通过触发缺页错误进入内核从而真正分配物理内存。

* **未使用时0填充机制**

  * **地址空间**：进程地址空间有三个区域，其中`text`区域存放指令，`data`区域存放初始化的全局变量，`BSS`区域存放未初始化或初始化为0的全局变量

  * **原理**：将BSS区域的所有页面全部映射到一个全为0的物理页面，从而节省程序启动时的物理内存分配。将BSS区域所有页面设置为只读，通过触发缺页异常进入内核真正分配一个全0的物理内存，并重新执行指令。

* **写时复制机制**：`fork`系统调用创建子进程，子进程的页表和父进程页表共享物理内存，将子进程与父进程的`PTES`均设置为只读，只有当两者中任一个进程对内存有`write`时才会分配并复制内存，并将该页面映射到子进程。从而优化`fork`后立马调用`exec`的场景。

* **按需分配页面**：在加载进程时，只加载部分指令到内存，其余`PTES`通过缺页异常来懒加载。涉及到页面置换问题。

* **内存映射文件**

  * **系统调用**：`mmap()`从文件描述符对应的文件的偏移量的位置开始，映射长度为len的内容到虚拟内存地址VA，同时我们需要加上一些保护，比如只读或者读写。
  * **原理**：将完整或者部分文件加载到内存中，这样就可以通过内存地址相关的load或者store指令来操纵文件。


### 中断和设备驱动

*中断是硬件请求CPU处理的机制，驱动是操作系统中与设备交互的程序*

* **硬件**
  * **外设**：在主板上的各种芯片，以及可以连接到主板的各种设备
  * `PLIC`：中断管理设备，接收多个设备的中断信号将其映射为对应的**中断号**，然后将中断号传给CPU核心，CPU核心根据中断号执行相应的中断处理程序。
    * PLIC会通知当前有一个待处理的中断
    * 其中一个CPU核会Claim接收中断，这样PLIC就不会把中断发给其他的CPU处理
    * CPU核处理完中断之后，CPU会通知PLIC
    * PLIC将不再保存中断的信息
* **中断**
  * 仍然利用`TRAP`机制实现，与**系统调用**和**缺页异常**采用同一种机制实现。但是仍然存在一些**差异**
    * **异步**：中断和当前运行在CPU上的进程没有任何关系。而系统调用需要保存进程上下文。
    * **并发**：产生中断的外设和CPU是相互独立，同时运行的，是真正的并行运行。例如网卡和CPU
    * **对设备编程**：中断需要对设备进行编程，控制设备操作。
  * 所有外设都连接到CPU上，通过`PLIC`(Platform Level Interrupt Control)来管理设备中断，路由中断到某个CPU核心
  * **中断相关寄存器**
    * `SIE`：不同的位针对不同中断的使能。分别针对外部设备中断，软件中断使能以及定时器中断使能。
    * `SSTATUS`：控制所有中断的使能。`SIE`和`SSTATUS`在每个CPU核中都有。
    * `SIP`：发生中断时，保存中断类型。
    * `SCAUSE`：保存陷阱的类型
    * `STVEC`：保存程序计数器，保证中断、缺页异常或者系统调用结束后，程序能够继续正常执行。
* **驱动**
  * 管理内核的代码就是驱动，**驱动都在内核中**
  * 驱动的架构一般分为`top`和`bottom`两个部分，其中`bottom`一般是中断处理程序，当某个CPU核心接收中断就会调用该程序。`top`是提供给用户进程或内核其他部分程序调用的**接口**，例如`read()`和`write()`
  * 驱动中包含存储数据的`buffer`，无论是`top`还是`bottom`中的程序都可以对其进行读写。但是由于`bottom`中的`interrupt handler`使用内核页表，因为中断例程是独立于进程的，所以不能随意读写数据。
* **设备编程**：通过`I/O`端口映射，主板厂商将设备映射到物理地址上，便可以用与读写内存相同的方式对设备进行编程，虽然这些设备并非真实存在`RAM`中

## 实验部分

### Page Tables

#### 检测被访问过的页面

* **背景**：一些垃圾回收机制如果能够获取页面是否被访问的信息，将能够提高效率。
* **目的**：实现检测页表访问位并将结果返回到用户态
* **预备知识**
  * RISC-V硬件处理TLB缺失时，将新的虚拟地址载入时，会将相应的页面访问位置位
* **任务**
  * 代码实现在`kernel/sysproc.c`中的`sys_pgaccess()`，参数如下
    * 第一个要检查的用户页面的虚拟地址
    * 将要检查页面的数量
    * 用于返回掩码结果的用户空间地址
  * 使用`argaddr()`和`argint()`解析参数
  * 最好在内核使用一个临时的缓冲区保存要输出的位掩码，利用`copyout()`输出
  * 可以设置扫描页面数量的上限
  * 使用`walk()`来找到正确的`PTE`
  * 需要在`kernel/riscv.h`中定义`PTE_A`
  * 确保检查`PTE_A`后，将其清零。否则无法判断在上次检查之后该页面有没有再次被访问
  * 使用`vmprint()`来帮助debug
* **代码**

### Traps

*帧指针、栈指针是函数调用的灵魂，栈指针负责为局部变量和参数分配空间，帧指针扮演寻找变量和参数的基石*

*内核堆栈和进程堆栈没有联系，只是他们都和进程一一对应*

#### RISC-V汇编初识

* **目的**：了解RISC-V中的汇编指令

* **预备知识**：汇编语言

* **任务**
  * 编译`fs.img`，阅读`call.asm`中的`g`、`f`、`main`函数。回答以下问题并将答案编辑在`answers-traps.txt`文件之中
    * 哪些寄存器保存传递给函数的参数，例如：当`main`函数调用`printf`函数时，哪个寄存器保存了13？
    
      $a_0,a_1,a_2$，其中调用`printf`时，$a_2$寄存器保存了13
    
    * 在`main`函数的汇编码中，哪里调用了`f`，`g`这两个函数
    
    * 函数 `printf` 位于什么地址？
    
      `0x616`，在`RISCV`指令中，`auipc`指令一般结合其他跳转指令来执行，因为在`RISCV`指令中无法表示32位的立即数，因此需要用`auipc`指令将一个20位立即数左移12位加上`PC`，存储在目的寄存器中。然后再由接下来的跳转指令用12位立即数填充低12位，最后实现跳转到`PC`附近的32位地址。这里的计算就是：$0x30+1510_{(10)}=0x616$
    
    * 在 `jalr` 到 `main` 中的 `printf` 之后，寄存器 `ra` 中的值是什么？
    
      38，即当前地址+4
    
    * 运行以下代码
    
      ```C
      unsigned int i = 0x00646c72;
      printf("H%x Wo%s", 57616, &i);
      ```
    
      请问输出是什么？(这段代码的输出依赖于RISC-V的小端模式)。若这段代码运行在大端模式的机器中，要使输出相同，应该给$\;i\;$赋什么值？需要将57616改为其他值么？
    
      输出是`Hell0 World`，不用更改`57616`，只需要将`0x00646c72`改为`0x726c6400`
    
    * 在这行代码中
    
      ```C
      printf("x=%d y=%d", 3);
      ```
    
      $y=\;$后面会出现什么数字？(*提示：这个数据不是某个特定的数字*) 为什么会出现这种情况？
    
      y后面的数字是随机的数字，取决于从栈帧中取到a2的垃圾数据

#### 堆栈回溯

* **背景**：在调试过程中，如果知道在出错点处的堆栈中存在哪些没有返回的函数调用是非常有帮助的

* **任务**
  * 在`kernel/printf.c`中实现`backtrace()`函数，并在`sys_sleep`中调用
  * 在`panic`函数中调用`backtrace`，以便在系统崩溃时了解相关信息
  
* **代码**
  
  * 修改`riscv.h`
  
    ```C
    // read the s0 register
    static inline uint64
    r_fp()
    {
      uint64 x;
      asm volatile("mv %0, s0" : "=r" (x) );
      return x;
    }
    ```
  
  * `backtrace()`
  
    ```C
    void
    backtrace(void)
    {
      printf("backtrace:\n");
      uint64 fp = r_fp();
      uint64 head = PGROUNDDOWN(fp);
      uint64 tail = PGROUNDUP(fp);
      uint64 ra;
    
      while((fp >= head) && fp <= tail){
        ra = *(uint64*)(fp - 8);
        fp = *(uint64*)(fp - 16);
        printf("%p\n", ra);
      }
    }
    ```
  
  * `panic(char* s)`
  
    ```C
    void
    panic(char *s)
    {
      pr.locking = 0;
      printf("panic: ");
      printf(s);
      printf("\n");
      backtrace();
      panicked = 1; // freeze uart output from other CPUs
      for(;;)
        ;
    }
    ```
  
  * `sys_sleep`
  
    ```C
    uint64
    sys_sleep(void)
    {
      int n;
      uint ticks0;
    
      if(argint(0, &n) < 0)
        return -1;
      acquire(&tickslock);
      ticks0 = ticks;
      while(ticks - ticks0 < n){
        if(myproc()->killed){
          release(&tickslock);
          return -1;
        }
        sleep(&ticks, &tickslock);
      }
      release(&tickslock);
      backtrace();
      return 0;
    }
    ```

#### 闹钟

* **背景**：计算密集型进程往往想知道自己消耗了多少时间，同时一些进程希望定期做某件任务

* **任务**

  * 实现一个**用户级中断**处理程序，`sigalarm(interval, handler)`
  * 调用`sigalarm(n, fn)`的函数每经过`n`个CPU时钟，`kernel`就会调用`fn`，当`fn`返回后，进程恢复继续执行。(*本质就是TRAP*)
  * 当应用调用`sigalarm(0,0)`时，`kernel`应该停止周期闹铃
  * 在`Makefile`中添加`alarmtest.c`，同时在`kernel`添加`sigalarm`和`sigturn`
  * `user/alarmtest.asm`或许对调试有所帮助

* **代码**

  * 修改`Makefile`

    ```makefile
    ifeq ($(LAB),traps)
    UPROGS += \
    	$U/_call\
    	$U/_bttest\
    	$U/_alarmtest
    endif
    ```

  * 修改`usys.pl`

    ```perl
    entry("sigalarm");
    entry("sigreturn");
    ```

  * 修改`syscall.h`

    ```c
    #define SYS_sigalarm    22
    #define SYS_sigreturn     23
    ```

  * 修改`syscall.c`

    ```C
    ...
    extern uint64 sys_sigalarm(void);
    extern uint64 sys_sigturn(void);
    
    static uint64 (*syscalls[])(void) = {
    	...
    	[SYS_sigalarm]  sys_sigalarm,
    	[SYS_sigreturn]   sys_sigreturn,
    }
    ```

  * 修改`proc.h`

    ```c
    struct proc {
    	...
    	// these are private to the process, so p->lock need not be held.
    	...
    	uint64 interval;             // call handler for every interval ticks
      uint64 handler;              // run every interval ticks
      uint64 count;                // time left to call handler
      ...
    }
    ```

  * 修改`proc.c`

    ```C
    static struct proc*
    allocproc(void)
    {
    	...
    	p->count = 0;
    	...
    }
    
    int
    sigalarm(uint64 interval, uint64 handler) {
      struct proc *p = myproc();
      p->interval = interval;
      p->handler = handler;
      return 0;
    }
    ```
  
  * 修改`trap.c`
  
    ```c
    if(which_dev == 2){
      if(++p->count >= p->interval) {
        p->trapframe->epc = p->handler;
        p->count = 0;
      }
      yield();
    }
    ```
    
  * 修改`sysproc.c`
  
    ```c
    uint64
    sys_sigalarm(void)
    {
      uint64 interval;
      uint64 handler;
      
      if(argaddr(0, &interval) < 0)
        return -1;
      if(argaddr(1, &handler) < 0)
        return -1;
      return sigalarm(interval, handler);
    }
    ```
  

### Copy-on-Write

#### 实现写时复制

* **背景**：`fork()`将父进程的所有内存复制到子进程，如果父进程占用内存很大那么复制将会十分耗时，而且如果子进程在调用`fork()`后，直接调用`exec()`那么之前所做的复制都是无效的工作，这是对`CPU`资源的浪费。
* **任务**
  * 修改`uvmcopy()`将父进程的物理页面映射到子进程的页表之中。同时将父进程和子进程页表的`PTE`均设置为只读。
  * 修改`usertrap()`识别COW页面的缺页异常，触发时通过`kalloc()`给子进程分配物理页面，并复制父进程内容，修改`PTE_W`
  * 确保对没有被任何进程的页表所引用的页面进行回收。可以通过给每个物理页面记录一个`reference count`。当`kalloc()`时将`reference count`设置为1，当`reference count`为0时，调用`kfree()`回收页面。可以使用一个固定大小的整型数组，但是必须计算出合理的数组大小，并设计合理的索引方式。例如，你可以将物理页面地址除以4096作为索引，并通过最高的物理地址来计算出数组的大小。
  * 修改`copyout()`进行复制，就像遇到缺页异常一样。
  * 当一个COW页面发生缺页异常，如果此时没有多余的内存，那么选择将该进程杀死。
* **代码**
  * 

