---
title: MIT 6.S081
date: 2023-03-16 21:37:59
tags:

---

# MIT 6.S081

## 配置问题

### **本地环境**

* **设备**：*MacBook Air 2020 ( m1 芯片 )*
* **编译器**：*Apple clang version 14.0.0 (clang-1400.0.29.202)*

### 问题清单

* **无穷递归**
  * **问题描述**：*error: infinite recursion detected [-Werror=infinite-recursion]*
  * **解决方法**：在**sh.c**中**runcmd**函数签名上添加*\__attribute__((noreturn))*

## 理论部分

### 陷阱和系统调用

* **陷阱机制**：内核通过对**特定控制寄存器**进行写操作，CPU利用这些寄存器的信息处理陷阱
  * **特定控制寄存器**
    * *STVEC*：保存陷阱处理代码的地址
    * *SEPC*：保存进入陷阱前的PC
    * *SCAUSE*：保存陷阱的类型
    * *SSCRATCH*：
    * *SSTATUS*：分为SIE位、SPP位，前者控制中断使能，后者表示陷阱来自内核态还是用户态
  * **以上这些特定控制寄存器只能在特权级进行修改**
  * **大致流程**
    * *禁用中断(SIE位清零)*
    * *保存PC至SEPC*
    * *保存发生陷阱时的特权级别(SPP位)*
    * *设置scause(反应陷阱的原因)*
    * *设置CPU到内核态*
    * *将STVEC复制到PC*
    * *执行新PC*
  * **注意事项**：目前仅仅在用户态做了很少的工作，即没有切换页表，也没有切换内核堆栈，更没有保存任何寄存器。
* **来自用户态的陷阱**
  * **高视角下用户态陷阱的执行过程**：*uservec*$\to$*usertrap*$\to$*usertrapset*$\to$*userret*
  * **蹦床页面**：由于最初并未对页表进行切换，因此**STEVC**必须同时在**内核页表和用户进程页表**中进行**有效映射**
    * *该页面被映射到每个进程的地址空间的最高地址处*
  * **保存现场**：保存进入陷阱前的32个寄存器状态，此时需要**SSCRATCH**辅助保存，**因为此时没有空闲通用寄存器**
    * 将$a_0$与**SSCRATCH**交换数据，$a_0$在交换之后内部存储的是Trampframe的基址
  * **TRAMPFRAME**
    * *用于存储进入陷阱前状态以及返回值，此页面由内核维护，用户进程不能访问*
    * *存放着当前进程的内核堆栈地址*
    * *存放着内核页表的地址*
    * *CPU标示号*
    * *陷阱处理C函数地址*
  * **USERTRAP**：确定造成陷阱的原因，对陷阱处理，并返回
    * 首先将**STVEC**更改为**kernelvec**，这样在内核中发生的**TRAP**就是被kernelvec处理
    * 然后保存**SEPC**，因为**TRAP**过程中可能会调用**yield**（时钟中断）函数切换到另外一个进程的内核线程，该线程可能会返回用户空间，这个过程将会改变**SEPC**的值。（==不太懂==）
    * 根据**TRAP**的不同类型分别处理
    * **将程序计数器加4**：当前的程序计数器指向ecall，我们希望**TRAP**执行完后执行ecall的下一条指令
    * 最后检查该设备中断是否是时钟中断，若是则执行**yield**函数放弃CPU
  * **返回用户空间**
    * **usertrapret**：配置**TRAPFRAME**以处理下一次来自用户空间的**TRAP**。包括配置**STVEC**为**uservec**，配置**SEPC**为之前的程序计数器，配置**uservec**依赖的各种参数(*kernel_pgtbl...*)，最后调用**userret**
    * **userret**：接收**TRAPFRAME**和**PGTBL**参数。首先将**TRAPFRAME**中保存的$a_0$与**SSCRATCH**交换，交换后$a_0$存储的是**TRAPFRAME**的地址，以其为基址将**TRAPFRAME**中保存的状态恢复到CPU中的寄存器中。最后$a_0$与**SSCRATCH**交换，以便下一次**TRAP**发生时，**SSCRATCH**保存着该进程的**TRAPFRAME**的地址
* **来自内核态的陷阱**
  * **保存现场**：kernelvec首先将寄存器状态压入该线程的内核堆栈，以便当**TRAP**返回的时候从堆栈恢复现场，接着调用**kerneltrap**
  * **陷阱类型**：来自内核态的陷阱的类型分为**设备中断**和**异常**。若是设备中断，则会检查并执行相应的例程。若是异常，操作系统则会崩溃
    * **定时器中断**是设备中断中比较特殊的存在。当前线程会放弃CPU，在将来某个时间点通过堆栈恢复状态继续执行。
  
  * **返回**：复制**SEPC**到**PC**，并恢复现场。
  

## 实验部分

### Page Tables

#### 检测被访问过的页面

* **背景**：一些垃圾回收机制如果能够获取页面是否被访问的信息，将能够提高效率。
* **目的**：实现检测页表访问位并将结果返回到用户态
* **预备知识**
  * RISC-V硬件处理TLB缺失时，将新的虚拟地址载入时，会将相应的页面访问位置位
* **任务**
  * 代码实现在**kernel/sysproc.c**中的**sys_pgaccess**()，参数如下
    * 第一个要检查的用户页面的虚拟地址
    * 将要检查页面的数量
    * 用于返回掩码结果的用户空间地址
  * 使用**argaddr()**和**argint()**解析参数
  * 最好在内核使用一个临时的缓冲区保存要输出的位掩码，利用**copyout**()输出
  * 可以设置扫描页面数量的上限
  * 使用walk()来找到正确的PTEs
  * 需要在**kernel/riscv.h**中定义**PTE_A**
  * 确保检查**PTE_A**后，将其清零。否则无法判断在上次检查之后该页面有没有再次被访问
  * 使用**vmprint()**来帮助debug
* **代码**

### Traps

#### RISC-V assembly

* **目的**：了解RISC-V中的汇编指令
* **预备知识**：汇编语言
* **任务**
  * 编译**fs.img**，阅读**call.asm**中的**g、f、main**函数。回答以下问题并将答案编辑在answers-traps.txt文件之中
    * *哪些寄存器保存传递给函数的参数，例如：当main函数调用printf函数时，哪个寄存器保存了13？*
    * *在main函数的汇编码中，哪里调用了f，g这两个函数*
    * *函数 printf 位于什么地址？*
    * *在 jalr 到 main 中的 printf 之后，寄存器 ra 中的值是什么？*
  * 
