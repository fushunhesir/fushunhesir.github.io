---
layout: wiki
title: Network driver
wiki: MIT-6.S081
order: 28
date: 2023-05-019 14:01:34


---

## 网络驱动

**背景**：

使用E1000网卡处理网络通信。事实上，`qemu`模拟了E1000和局域网。在这个模拟局域网上，xv6的IP地址为`10.0.2.15`，真实主机IP地址为`10.0.2.2`。当`xv6`使用`E1000`向`10.0.2.2`发送数据包时，会将数据包传递到真实主机上对应的应用程序。

packets.pcap文件中记录了传入和传出的数据包。通过一下命令查看：

```shell
tcpdump -XXnr packets.pcap
```

`kernel/e1000.c`包含e1000的初始化代码以及需要你完善的用于发送和接收数据包的函数。

`kernel/e000_dev.h`包含e1000定义的寄存器和标志位的定义，可以在英特尔`E1000`软件开发人员手册中进一步了解。

`kernel/net.c`和`kernel/ne.h`包含一个简单的网络协议栈，实现了`IP`、`UDP`和`ARP`协议。这些文件还包含用于保存数据包的数据结构，称为`mbuf`。

`kernel/pci.c`包含在`xv6`启动时在`PCI`总线上搜索`E1000`卡的代码。

**任务**

* 完善`kernel/e1000.c`用于发送和接收数据包的函数`e1000_transmit()`和`e1000_recv()`
* [`E1000`](https://pdos.csail.mit.edu/6.S081/2021/readings/8254x_GBe_SDM.pdf)的软件开发手册对你来说应该是有帮助的：
  * Section 2对设备进行整体概述。
  * Section 3.2描述接收包的大致过程。
  * Section 3.3 和 Section 3.4描述发送包的大致过程。
  * Section 13介绍`E1000`的寄存器。
  * Section 14帮助你理解`xv6`中的初始化代码。



本手册涵盖了几个密切相关的以太网控制器。QEMU模拟82540EM。现在浏览第2章，感受一下设备。要写司机，您需要熟悉第3章和第14章以及4.1章（尽管不是4.1的小节）。您还需要使用第13章作为参考。其他章节主要涵盖了您的驱动程序不必与之交互的E1000组件。一开始不要担心细节；只要了解一下文档的结构，这样你以后就可以找到东西了。E1000有许多高级功能，其中大部分你可以忽略。完成这个实验室只需要一小套基本功能。

我们在e1000.c中为您提供的e1000_init()函数将E1000配置为读取要从RAM传输的数据包，并将接收的数据包写入RAM。这种技术被称为DMA，用于直接内存访问，指的是E1000硬件直接向/从RAM写入和读取数据包。

由于数据包的突发可能比驱动程序处理速度快，e1000_init()为E1000提供了多个缓冲区，E1000可以向其中写入数据包。E1000要求这些缓冲区由RAM中的“描述符”数组来描述；每个描述符都包含RAM中的地址，E1000可以写入接收的数据包。struct rx_desc描述了描述符格式。描述符数组称为接收环或接收队列。这是一个圆形环，当卡或驱动程序到达数组的末尾时，它会包装回开头。e1000_init()使用mbufalloc()将E1000的mbuf数据包缓冲区分配给DMA。还有一个传输环，驱动程序将它希望E1000发送的数据包放入其中。e1000_init()将两个环配置为具有RX_RING_SIZE和TX_RING_SIZE的大小。

当net.c中的网络堆栈需要发送数据包时，它会使用保存要发送的数据包的mbuf调用e1000_transmit()。您的传输代码必须在TX（传输）环的描述符中放置指向数据包数据的指针。struct tx_desc描述了描述符格式。您需要确保最终释放每个mbuf，但只有在E1000完成传输数据包后（E1000在描述符中设置E1000_TXD_STAT_DD位来指示这一点）。

当E1000从以太网接收每个数据包时，它首先将数据包发送到下一个RX（接收）环描述符指向的mbuf，然后生成中断。您的e1000_recv()代码必须扫描RX环，并通过调用net_rx()将每个新数据包的mbuf发送到网络堆栈（在net.c中）。然后，您需要分配一个新的mbuf并将其放入描述符中，这样当E1000再次到达RX环中的该点时，它会找到一个新的缓冲区，以便DMA一个新的数据包。

除了在RAM中读取和写入描述符环外，您的驱动程序还需要通过其内存映射的控制寄存器与E1000交互，以检测何时可用的数据包，并通知E1000驱动程序已用要发送的数据包填写了一些TX描述符。全局变量regs持有指向E1000第一个控制寄存器的指针；您的驱动程序可以通过将regs索引为数组来获取其他寄存器。您特别需要使用索引E1000_RDT和E1000_TDT。

要测试您的驱动程序，请在一个窗口中运行make服务器，在另一个窗口中运行make qemu，然后在xv6中运行nettests。nettests中的第一个测试试图将UDP数据包发送到主机操作系统，发送到使服务器运行的程序。如果您尚未完成实验室，E1000驱动程序实际上不会发送数据包，也不会发生任何事情。

完成实验室后，E1000驱动程序将发送数据包，qemu将将其发送到您的主机计算机，使服务器将看到它，它将发送响应数据包，然后E1000驱动程序和nettests将看到响应数据包。然而，在主机发送回复之前，它会向xv6发送一个“ARP”请求数据包，以查找其48位以太网地址，并希望xv6以ARP回复进行响应。一旦您完成E1000驱动程序的工作，kernel/net.c将处理此问题。如果一切顺利，nettests将打印测试ping：好的，并使服务器将打印来自xv6的消息！





首先将打印语句添加到e1000_transmit()和e1000_recv()中，并运行make服务器和（在xv6中）nettests。您应该从打印语句中看到，nettests会生成对e1000_transmit的调用。

实现e1000_transmit的一些提示：

首先通过读取E1000_TDT控制寄存器，向E1000询问它期待下一个数据包的TX环形索引。

然后检查戒指是否溢出。如果E1000_TDT索引的描述符中没有设置E1000_TXD_STAT_DD，则E1000尚未完成相应的先前传输请求，因此返回错误。

否则，使用mbuffree（）释放从该描述符传输的最后一个mbuf（如果有的话）。

然后填写描述符。m->head指向内存中的数据包内容，m->len是数据包长度。设置必要的cmd标志（查看E1000手册中的第3.3节），并隐藏一个指向mbuf的指针，以便以后释放。

最后，通过在E1000_TDT modulo TX_RING_SIZE中添加一个来更新环形位置。

如果e1000_transmit()成功将mbuf添加到环中，则返回0。失败时（例如，没有可用的描述符来传输mbuf），返回-1，以便调用者知道释放mbuf。

实现e1000_recv的一些提示：

首先，通过获取E1000_RDT控制寄存器并添加一个模RX_RING_SIZE，向E1000询问下一个等待接收数据包（如果有的话）所在的环形索引。

然后通过检查描述符状态部分中的E1000_RXD_STAT_DD位来检查新数据包是否可用。如果没有，就停下来。

否则，将mbuf的m->len更新为描述符中报告的长度。使用net_rx()将mbuf传递到网络堆栈。

然后使用mbufalloc()分配一个新的mbuf来替换刚刚给net_rx()的mbuf。将其数据指针（m->head）编程到描述符中。将描述符的状态位清除为零。

最后，将E1000_RDT寄存器更新为处理的最后一个环描述符的索引。

e1000_init()用mbufs初始化RX环，你会想看看它是如何做到的，也许还可以借用代码。

在某个时候，曾经到达的数据包总数将超过环大小（16）；请确保您的代码可以处理。

您需要锁来应对xv6可能从多个进程使用E1000的可能性，或者在中断到达时可能在内核线程中使用E1000。
