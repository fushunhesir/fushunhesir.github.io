---
layout: wiki
title: Copy-On-Write
wiki: MIT-6.S081
order: 26
---

# 实验 Copy-on-Write

## 实现写时复制

* **背景**：`fork()`将父进程的所有内存复制到子进程，如果父进程占用内存很大那么复制将会十分耗时，而且如果子进程在调用`fork()`后，直接调用`exec()`那么之前所做的复制都是无效的工作，这是对`CPU`资源的浪费。
* **任务**
  * 修改`uvmcopy()`将父进程的物理页面映射到子进程的页表之中。同时将父进程和子进程页表的`PTE`均设置为只读。
  * 修改`usertrap()`识别COW页面的缺页异常，触发时通过`kalloc()`给子进程分配物理页面，并复制父进程内容，修改`PTE_W`
  * 确保对没有被任何进程的页表所引用的页面进行回收。可以通过给每个物理页面记录一个`reference count`。当`kalloc()`时将`reference count`设置为1，当`reference count`为0时，调用`kfree()`回收页面。可以使用一个固定大小的整型数组，但是必须计算出合理的数组大小，并设计合理的索引方式。例如，你可以将物理页面地址除以4096作为索引，并通过最高的物理地址来计算出数组的大小。
  * 修改`copyout()`进行复制，就像遇到缺页异常一样。
  * 当一个COW页面发生缺页异常，如果此时没有多余的内存，那么选择将该进程杀死。
* **代码**
  * 
