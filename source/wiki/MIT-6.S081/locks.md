---
layout: wiki
wiki: MIT-6.S081
title: 锁机制
order: 7

---

锁存在的目的是解决并发问题。操作系统之所以面对并发问题，是因为物理硬件的共享。现代的计算机一般是多核心，可以独立执行指令，他们共享着物理内存，因此存在着对同一块内存，一颗核心进行读，另外一颗核心进行写的情况。甚至多个核心同时写的情况。除此之外，即使只有一颗核心也需要应对多个线程切换，交错运行的场景。

**并发是指由于多核并行、线程切换或中断导致的多指令流交替执行的情况**

内核设计会允许大量的并发，以此来提高系统的性能。由此催生了以并发下正确性为目的的**并发控制技术**。

*锁提供互斥，只有持有锁的CPU能够对该数据区进行操作，确保了对数据操作的正确性。但是它会限制系统性能，因为锁会序列化并发操作。*

## 竞争条件

竞争条件就是同时对内存进行访问，并且其中至少有一个写操作。这样的情况通常会导致错误，并且难以调试。因为，添加一个打印语句从而增加的时间就可能消除了竞争条件。

**解决竞争条件的方式一般就是加锁。**

```C
struct element *list = 0;
struct lock listlock;

void
push(int data) {
	struct element *l;
	l = malloc(sizeof *l);
	l->data = data;
	acquire(&listlock);
	l->next = list;
	list = l;
	release(&listlock);
}

```

这里`acquire()`和`release()`之间的区域也称为**临界区**。

通常所说的锁保护了数据，实际上是锁保护了对象的不变性质。比如在上述的`push()`中，`list`的性质是始终指向列表的表头，但是当执行完`l->next = list`后，这个不变性被暂时破坏了，如果有其他依赖于这个不变特性的指令在另外一个CPU并发执行，就会引起错误。所以锁实际上是保护了这样一种不变特性。

如果多个CPU同时请求锁会引发锁的竞争，在真实的操作系统中设计了数据结构和算法来避免锁的竞争，
