[{"title":"基金投资","path":"/2023/04/29/基金投资/","content":"基金投资 如何分析一支基金 基金的投资策略：基金的投资策略会影响基金的风险和收益水平，因此投资者应该了解基金的投资方向和策略。例如，一些基金可能采取价值投资、成长投资、指数跟踪等不同的投资策略，不同的策略可能带来不同的投资风险和回报。 基金的历史表现：基金的历史表现可以反映出基金的投资能力和风险水平，因此投资者应该关注基金的历史表现。可以通过查看基金的过去一年、三年、五年或更长时间的表现，了解基金的平均年回报率、波动率和风险调整收益等指标。 基金管理团队：基金的管理团队会对基金的投资策略和业绩产生重要影响，因此投资者应该关注基金管理团队的资历和经验。可以查看基金管理人员的履历和过去的投资表现，以了解其投资风格和能力。 基金费用：基金的费用会对投资收益产生影响，因此投资者应该关注基金的费用情况。包括管理费、销售服务费、赎回费等各种费用。通常来说，费用较低的基金更有可能获得较高的投资收益。 市场环境：市场环境会对基金的投资表现产生影响，因此投资者应该了解当前市场环境和趋势。例如，如果当前市场处于牛市阶段，那么股票型基金可能表现较好；如果当前市场处于熊市阶段，那么债券型基金可能更适合投资。 基金规模和流动性：基金规模和流动性会影响基金的投资能力和风险水平，因此投资者应该了解基金的规模和流动性情况。一般来说，较大规模的基金通常能够分散投资风险，而流动性较好的基金则更容易买卖","tags":["碎片化学习","基金基础"],"categories":["成长主线","金融理财"]},{"title":"GDB","path":"/2023/04/19/GDB/","content":"GDB 多线程调试","tags":["命令行调试"],"categories":["技术主线","调试工具"]},{"title":"CMake","path":"/2023/04/16/Cmake/","content":"CMake","tags":["CMake","碎片化学习"],"categories":["技术主线","编译工具"]},{"title":"Network-Programming","path":"/2023/04/13/Network-Programming/","content":"网络编程 Unix哲学——万物皆文件 套接口 流式套接口stream socket 可靠的，面向连接的套接口 报式套接口datagram socket 无连接的套接口 注意 TCP协议允许在传输层对数据进行分段，而UDP则不会，UPD会在发送前在主机上完成分段操作 字节序和数据结构 字节序 大端序：低字节存高位数据，高字节存低位数据 小端序：低字节存地位数据，高字节存高位数据 网络序：网络中采用大端序 数据结构 套接口描述符：本质上就是文件描述符，符合Linux的设计哲学，类型是整型。 struct addrinfo struct addrinfo { int ai_flags; /* Input flags. */ int ai_family; /* Protocol family for socket. */ int ai_socktype; /* Socket type. */ int ai_protocol; /* Protocol for socket. */ socklen_t ai_addrlen; /* Length of socket address. */ struct sockaddr *ai_addr; /* Socket address for socket. */ char *ai_canonname; /* Canonical name for service location. */ struct addrinfo *ai_next; /* Pointer to next in list. */ }; ai_flag：用于标识 getaddrinfo() 函数返回结果的标志字段，可以设置为以下常量之一或它们的按位或组合。其中AI前缀表示Address Information AI_PASSIVE：用于指定用于套接字的地址是通配地址，适用于服务器端程序，表示服务器端将监听所有可用的网络接口。 AI_CANONNAME：用于指定返回的主机名是否是规范名，如果设置了该标志，则 getaddrinfo() 会将主机名转换为其规范名，否则返回的主机名可能是别名。 AI_NUMERICHOST：用于指定主机名必须是一个 IP 地址字符串，而不是一个主机名，如果指定了该标志，则 getaddrinfo() 不会尝试解析主机名。 AI_NUMERICSERV：用于指定服务名必须是一个端口号字符串，而不是一个服务名，如果指定了该标志，则 getaddrinfo() 不会尝试查找服务名。 AI_ADDRCONFIG：用于指定只返回与本地系统的地址族相匹配的地址，例如 IPv4 地址族的系统将只返回 IPv4 地址。 AI_V4MAPPED：用于指定如果没有找到与查询参数完全匹配的 IPv6 地址，那么getaddrinfo()将尝试返回一个 IPv4 映射的 IPv6 地址。 ai_family：表示协议类别，AF_INET表示IPV4，AF_UNSPEC表示自动判定 ai_addr struct sockaddr { unsigned short sa_family; // address family, AF_xxx char sa_data[14]; // 14 bytes of protocol address }; 通常采用它的等价结构体 struct sockaddr_in { short int sin_family; // Address family, AF_INET unsigned short int sin_port; // Port number struct in_addr sin_addr; // Internet address unsigned char sin_zero[8]; // 與 struct sockaddr 相同的大小 }; sin_addr // Internet address (a structure for historical reasons) struct in_addr { uint32_t s_addr; // that&#39;s a 32-bit int (4 bytes) }; 函数 inet_pton(family, \"IP address\", &amp;(struct sa.in_addr))：将字符串形式的IP地址转化为字节流存储 inet_ntop(family, &amp;(struct sa.in_addr), buffer'address,len)：将字节流形式的IP地址转化为字符串存储 系统调用 getaddrinfo(...) 前身是用来做DNS查询的gethostbyname() #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netdb.h&gt; int getaddrinfo(const char *node, // 例如： &quot;www.example.com&quot; 或 IP const char *service, // 例如： &quot;http&quot; 或 port number const struct addrinfo *hints, struct addrinfo **res); hints-&gt;flags：设置为AI_PASSIVE代表将绑定至本机IP，作为监听套接口 res：返回结果 示例代码 int status; struct addrinfo hints; struct addrinfo *servinfo; // 将指向结果 memset(&amp;hints, 0, sizeof hints); // 确保 struct 为空 hints.ai_family = AF_UNSPEC; // 不用管是 IPv4 或 IPv6 hints.ai_socktype = SOCK_STREAM; // TCP stream sockets // 准备好连接 status = getaddrinfo(&quot;www.example.net&quot;, &quot;3490&quot;, &amp;hints, &amp;servinfo); // servinfo 现在指向有一个或多个 struct addrinfos 的链表 我一直说 serinfo 是一个链表，它有各种的地址资料。让我们写一个能快速 demo 的程序，来呈现这个资料。这个小程序 [18] 会打印出你在命令行中所指定的主机 IP address： ** showip.c -- 顯示命令列中所給的主機 IP address */ #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netdb.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;netinet/in.h&gt; int main(int argc, char *argv[]) { struct addrinfo hints, *res, *p; int status; char ipstr[INET6_ADDRSTRLEN]; if (argc != 2) { fprintf(stderr,&quot;usage: showip hostname &quot;); return 1; } memset(&amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; // AF_INET 或 AF_INET6 可以指定版本 hints.ai_socktype = SOCK_STREAM; if ((status = getaddrinfo(argv[1], NULL, &amp;hints, &amp;res)) != 0) { fprintf(stderr, &quot;getaddrinfo: %s &quot;, gai_strerror(status)); return 2; } printf(&quot;IP addresses for %s: &quot;, argv[1]); for(p = res;p != NULL; p = p-&gt;ai_next) { void *addr; char *ipver; // 取得本身地址的指针 // 在 IPv4 与 IPv6 中的栏位不同： if (p-&gt;ai_family == AF_INET) { // IPv4 struct sockaddr_in *ipv4 = (struct sockaddr_in *)p-&gt;ai_addr; addr = &amp;(ipv4-&gt;sin_addr); ipver = &quot;IPv4&quot;; } else { // IPv6 struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p-&gt;ai_addr; addr = &amp;(ipv6-&gt;sin6_addr); ipver = &quot;IPv6&quot;; } // convert the IP to a string and print it: inet_ntop(p-&gt;ai_family, addr, ipstr, sizeof ipstr); printf(&quot; %s: %s &quot;, ipver, ipstr); } freeaddrinfo(res); // 释放链表 return 0; } 结果 $ showip www.example.net IP addresses for www.example.net: IPv4: 192.0.2.88 $ showip ipv6.example.com IP addresses for ipv6.example.com: IPv4: 192.0.2.101 IPv6: 2001:db8:8c00:22::171 socket(...) 是一个系统调用，返回套接口描述符 #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int socket(int domain, int type, int protocol); domain：协议家族，PF_INET或者PF_INET6 type：socket的种类 protocal：传输层协议 int s; struct addrinfo hints, *res; ... // 运行查询 getaddrinfo(&quot;www.example.com&quot;, &quot;http&quot;, &amp;hints, &amp;res); s = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol); bind(...) 将socket绑定到指定的IP地址和端口号上 #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int bind(int sockfd, struct sockaddr *my_addr, int addrlen); socfd：套接字描述符 myaddr：getaddrinfo(...)返回的res中的res-&gt;ai_addr addrlen：getaddrinfo(...)返回的res中的res-&gt;ai_addrlen 示例代码 struct addrinfo hints, *res; int sockfd; // 首先，用 getaddrinfo() 载入地址结构： memset(&amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; // use IPv4 or IPv6, whichever hints.ai_socktype = SOCK_STREAM; hints.ai_flags = AI_PASSIVE; // fill in my IP for me getaddrinfo(NULL, &quot;3490&quot;, &amp;hints, &amp;res); // 建立一个 socket： sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol); // 将 socket bind 到我们传递给 getaddrinfo() 的 port： bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen); connect(...) 连接远端主机 #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int connect(int sockfd, struct sockaddr *serv_addr, int addrlen); socfd：套接字描述符 serv_addr：getaddrinfo(...)返回的res中的res-&gt;ai_addr addrlen：getaddrinfo(...)返回的res中的res-&gt;ai_addrlen 注意：kernel 会帮我们选择一个 local port，因此一般客户端连接的时候不用bind(...) 示例代码 struct addrinfo hints, *res; int sockfd; // 首先，用 getaddrinfo() 载入 address structs： memset(&amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_STREAM; getaddrinfo(&quot;www.example.com&quot;, &quot;3490&quot;, &amp;hints, &amp;res); // 建立一个 socket： sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol); // connect! connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen); listen(...) 更改此套接口的状态为监听状态 int listen(int sockfd, int backlog); backlog：代表连接此套接口队列的最大长度 一般调用顺序 getaddrinfo(); socket(); bind(); listen(); /* accept() 从这里开始 */ accept(...) 创建一个新的socket来处理进行对话 #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); addr：存放连接？？？ 示例代码 #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #define MYPORT &quot;3490&quot; // 使用者将连接的 port #define BACKLOG 10 // 在队列中可以有多少个连接在等待 int main(void) { struct sockaddr_storage their_addr; socklen_t addr_size; struct addrinfo hints, *res; int sockfd, new_fd; // !! 不要忘了帮这些调用做错误检查 !! // 首先，使用 getaddrinfo() 载入 address struct： memset(&amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; // 使用 IPv4 或 IPv6，都可以 hints.ai_socktype = SOCK_STREAM; hints.ai_flags = AI_PASSIVE; // 帮我填上我的 IP getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res); // 产生一个 socket，bind socket，并 listen socket： sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol); bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen); listen(sockfd, BACKLOG); // 现在接受一个进入的连接： addr_size = sizeof their_addr; new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;addr_size); // 准备好与 new_fd 这个 socket descriptor 进行沟通！ ... send(...) &amp; recv(...) 和远端主机通信 int send(int sockfd, const void *msg, int len, int flags); msg：发送的信息 len：发送的长度 flags：一般设置为0即可 注意：send(...)只会尽量将资料送出，并认为你之後会再次送出剩下没送出的部分，因此它不能保证送完数据 示例代码 char *msg = &quot;Beej was here!&quot;; int len, bytes_sent; len = strlen(msg); bytes_sent = send(sockfd, msg, len, 0); int recv(int sockfd, void *buf, int len, int flags); buf：接收消息的缓冲区 len：发送的长度 flags：一般设置为0即可 注意： recv(...)会返回 0，这表示远端主机已经关闭了连接 高等技术 阻塞 阻塞就是线程在某一条语句中sleep #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; sockfd = socket(PF_INET, SOCK_STREAM, 0); fcntl(sockfd, F_SETFL, O_NONBLOCK); fcntl：使阻塞函数成为非阻塞函数 select(...) 同时监听多个套接口 #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; int select(int numfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);","tags":["计算机网络","网络编程","碎片学习"],"categories":["技术主线","计算机网络"]},{"title":"C++","path":"/2023/04/11/C++/","content":"C++ 简介 杂点 endl：刷新缓冲区，保证内容真实写入到输出流 四种标准输入输出对象：cout、cin、clog、cerr 注释种类：分为单行注释(//，单行注释符号)和多行注释(/* */，注释界定符) 注释界定符号：不能嵌套 基本概念 类型：如何解释内存块里面的字节流 输入输出：输入是指流对象从某处读取字节，输出是指流对象将数据流写入到指定地址，操作对象都是字节流 命名空间：避免命名冲突，通过指定命名空间可避免冲突 注释：概述算法，确定变量用途 类：数据结构，定义了一个类型以及其关联的操作 C++基础 基本内置类型 机器实现原理：计算机中，数据以二进制位存储。通常将多个位组成块作为基本的寻址单位，即为每个这样的块分配一个地址而不是为每一个位分配地址。这个块就是字节，通常。多个字节组成一个更大的块，作为存储的基本单位，即存储读取操作是以这样一个块为单位进行的。这个大块就是字，通常。 类型转换： 复合类型 基于其他类型定义的类型 引用：引用即别名，它并没有实际占用内存，而只是绑定到一个已存在的对象上，同时引用无法修改绑定的对象，**因此必须初始化，且无法用字面量或表达式初始化。(例外const,[])**由于引用不是具体的一块内存，所以不能对引用建立引用。 int i = 2; int &amp;i = i; // correct int &amp;j = 2; // error 指针 const限定符 防止常量发生变化 初始化：const对象必须初始化，初始化的赋值操作是不被视为改变对象的操作 默认状态下，const仅在文件内有效 const引用 const int ci = 43; const int&amp; i = ci; // correct const int&amp; j = 4; // correct int&amp; ni = ci; // error i = 42; // error 原理：之所以对于非常量引用不可以用字面量和表达式初始化，是因为这样初始化的引用实际上绑定的是一个临时变量，修改它并不会让我们期望的内存块发生变化，而是那个临时内存发生变化，这是不符合我们的逻辑的，所以非法。而对于常量来讲，我们并不会修改它的值，所以不用担心这个问题。 技巧：const引用的对象不一定是常量，这代表const引用可以提供一个对该对象限制权限的接口。 指针和const","tags":["C++","系统学习"],"categories":["技术主线","编程语言","C++"]},{"title":"Math","path":"/2023/04/02/Math/","content":"高等数学 总纲：一步一步，以点带面，掌握思想，及时反思 前导知识 三角函数公式 倒数关系 商数关系 平方关系 诱导公式 奇变偶不变，符号看象限 基本公式 和差公式 积化和差公式 和差化积公式 倍角公式 函数与极限 数列的极限 数列：按一定顺序排列的数字 通项：生成数列的法则 数列极限： a：极限值 ：任意正数 收敛数列的性质 极限唯一性：数列收敛，极限唯一 有界性：数列收敛必有界，数列有界不一定收敛 保号性：极限值符号可以确定此前一些数列项的符号 当时 推论：如果数列{ }从某项起,且,那么 子序列收敛性：原数列收敛于n，那么任意子数列也收敛于n 子序列：从原数列中任意抽取的无限多项数字，这些的数字的排列顺序与在原数列中相同 函数的极限 函数极限的定义 自变量趋于有限值 函数在的去心邻域内有定义 左极限：从左侧靠近 右极限：从右侧靠近 极限存在的充分比必要条件为左极限和右极限同时存在且相等，不用关心函数在该点的取值 自变量趋近于无穷大时函数的极限 也称为水平渐近线 函数极限的性质 唯一性：如果极限存在，那么极限唯一 局部有界性：在极限的一个邻域内，满足有界 局部保号性：在极限的一个邻域内，满足符号和极限值相同 推论：如果极限存在，那么极限的符号和邻域内的符号相同 与数列极限的关系：如果，那么数列 无穷小与无穷大 无穷小 无穷小是一个函数， 定理：函数具有极限的充分必要条件：，其中是的无穷小 无穷大 定理：如果为无穷大，那么为无穷小；反之，如果，且为无穷小，那么为无穷大 极限运算法则 有限个无穷小之和为无穷小 有界函数与无穷小 乘积为无穷小 常数与无穷小的乘积为无穷小 有限个无穷小的乘积为无穷小 若，那么 若， 数列也满足以上规则 若，且那么 复合函数 极限存在准则 两个重要极限 准则 数列 如果数列，满足 当时 那么（***==夹逼准则==***） ==单调有界函数必有极限==（充分条件） 柯西极限存在准则 思想：越接近极限的数列项之间的差值会越来越小 数学：当时， 极限存在的充分必要条件 函数 如果在的去心邻域内或时 那么(夹逼准则) 函数在的左邻域内为单调有界，那么必存在 重要极限 ==== ==== 无穷小的比较 定义 高阶无穷小：，记为 低阶无穷小： 同阶无穷小： k阶无穷小： 等价无穷小：，记为，==在求极限中本质为恒等变换== 定理 与是等价无穷小的充分必要条件 思想：两者相差很小很小，即差值为高阶无穷小 数学： 两项之比的极限等于这两项的等价无穷小之比的极限 数学： 函数的连续性与间断点 连续性 在该点的极限和该点的函数值相同 左连续 在该点的左极限和函数值相同 右连续 在该点的右极限和函数值相同 间断点 在没有定义 在有定义但是极限不存在 在有定义，且极限也存在，但是极限不等于函数值 极限存在不一定连续，连续一定极限存在 分类 第一类间断点：左极限和右极限存在 可去间断点 跳跃间断点 第二类间断点：不是第一类 无穷间断点 振荡间断点 连续函数的运算与初等函数的连续性 连续函数的和、差、积、商的连续性 如果两函数都在连续，那么他们的和差积商都在连续 反函数与复合函数的连续性 如果函数在区间上单调增加(减少)且连续，那么他的反函数也在该区间上单调增加(减少)且连续 如果函数在连续，且在连续，那么复合函数也在连续 初等函数的连续性 一切初等函数在定义域内都是连续的 常用等价无穷小 幂指函数：形如，一般采取取对数方式处理 闭区间上连续函数的性质 有界性与最大值最小值定理 闭区间连续的函数一定能取到最大最小值 零点定理和介值定理 零点定理：在闭区间[a,b]上连续且异号，那么至少存在一点使 介值定理：在闭区间上连续且，那么至少存在一点使 一致连续性 定义：两个点靠的很近的时候，它们的差值也很小很小 定理：如果在闭区间上连续，那么也是一致连续 其他区间不一定，例如 导数与微分 导数概念 导数定义 可导：极限存在。导数本身是一个特殊极限，极限存在必须左极限和右极限都存在且相等，因此导数的左导数和右导数也必须存在且相等，同时隐含该点的函数值存在 可导的充要条件：左右导数存在且相等 导数： 单侧导数 左导数 右导数 导数的几何意义 函数图像中的切线斜率 导数可导性与连续性的关系 可导一定连续：因为导数里面已经蕴含了函数在该点存在函数值，而且左右导数相等 连续不一定可导：连续仅能保证在该点的函数值存在，并不能保证左右导数相等或者极限值不为无穷 奇偶函数与周期函数的导数的性质 奇函数的导数为偶函数 偶函数的导数为奇函数 周期函数的导函数也是周期函数，且周期相同 适合用定义求导数的情形 基本初等函数 求导法则不能应用的时候，比如不知道函数的可导性 分段函数 函数的求导法则 函数的和、差、积、商求导法则 ==前提：u，v均可微== 反函数的求导法则 在区间单调、可导且 复合函数的求导法则 基本求导法则与导数公式 常数和基本初等函数的导数公式 高阶导数 二阶及二阶以上的倒数统称为高阶导数 重要的n阶导数 隐函数及由参数方程所确定的函数的导数 隐函数的导数 隐函数：本质是函数所以必须保证每个自变量只能对应一个函数值，形式是自变量和因变量纠缠 隐函数求导：一般直接对方程两边同时求导即可，利用复合函数求导法则 幂指函数：一般采取对数求导法 参数方程所确定函数的导数 ， 函数的微分 微分的定义 可微： 微分： 函数的微分：，与有关 自变量的微分： 因此函数的微分与自变量的微分之商是导数 微分的几何意义 用切线来近似代替一小段的函数增量 微分与可导之间的区别与联系 微分准确描述了一种以直代曲的概念 在一元函数中，可微和可导是等价的，在多元函数中则不是 一阶微分不变性 定义： 意义：积分运算的基础 一元微分学的简单应用 平面曲线的切线与法线 切线方程： 法线方程： 平面曲线的曲率 微分中值定理与导数的应用 微分中值定理 罗尔定理 费马引理：==在的邻域内有定义且在处可导==，始终或，若可导，那么 驻点：若，那么为驻点。结合费马引理，在处取极值且可导，该点就是驻点，反之不然 证明思路：利用来得到两个结论，取交集推知必为0 罗尔定理 条件：连续，可导， 结论： 证明思路：利用闭区间连续函数最值定理，联合开区间连续得到费马引理的条件，从而推出结论 拉格朗日中值定理 条件：连续，可导 结论：存在 推论：如果一个函数在区间上可导且导数为0，那么该函数为常数函数 证明思路：通过辅助函数，将条件加强为罗尔定理条件，从而推知结论 柯西中值定理 条件：连续，可导， **结论：**那么存在 证明思路：利用拉格朗日中值定理的辅助函数，用参数方程替换原函数，即可推知 微分中值定理的重要作用：建立了函数值增量，自变量增量和导数之间的联系。是研究函数性态的重要工具 利用导数研究函数的性态 ==总结：== ==其中单调性，凹凸性对应性，拐点，极值点对应态。态是性的临界状态之一，当性和态都确定后，函数图像基本才能确定。== ==凹凸性分析本质可以视为对一阶导数的单调性分析== 基本概念 极值：函数某一个点周围的值都小于(大于)该点的值，那么这就是极值点 凹凸性 凹： 凸： 凹： 凸： 拐点：凹凸性发生变化的点，该点一定是连续点 函数为常数的条件与函数恒等式的证明 函数为常数的充要条件：在区间任意一点导数为0 两函数差值为常数的充要条件：两函数在定义域内任意一点的导数相等 两函数差值为0的充要条件：两函数在定义域内任意一点的导数相等，且 函数单调性充要判别法 前提条件 设在上连续，上可导 结论 在上单调不减 且在内在上单调递增 求单调区间一般方法 根据极值点和不可导点，分区间讨论 极值点的必要条件和充分判别法 必要条件：为极值点或该点不可导 极值第一充分判别定理 条件：函数在区间连续，函数在该点外可导 结论：该点左右两侧导数符号发生改变，那么该点为极值点。==并不需要该点可导== 极值第二充分判别定理 条件：函数在该点二阶可导 结论：，该点为极值点 本质：还是该点左右导数符号发生改变，不同在于，需要对该点性质进行强化(二阶可导) 求极值点的一般求法 找不可导点和的点 根据充分判别定理筛选，注意两个定理适应不同情况 凹凸性定义与充要判别法 定理1 条件：在连续，可导 结论：在上单调递增(减)该函数在该区间是凹(凸)的 定理2 条件：在连续，二阶可导 结论：该函数是凹(凸)的 函数凹凸性区间的求法 本质：求单调区间 拐点的充分判别法 必要条件：或者不存在 第一充分判别定理 条件：在区间连续，在该点外可导 结论：该点左右两侧符号发生改变，那么该点为拐点。==并不需要该点二阶可导== 第二充分判别定理 条件：函数在该点三阶可导 结论：，该点为极值点 本质：还是该点左右导数符号发生改变，不同在于，需要对该点性质进行强化(三阶可导) 利用性态分析做函数图像 求定义域、间断点 分析奇偶性、周期性等 单调性分析 凹凸性分析 列表 ==求渐近线== 垂直渐近线： 水平渐近线： 斜渐近线： 特殊点 绘图 洛必达法则 未定式： 洛必达法则：求导再求极限，==单侧极限也适用== 导数之比极限不存在，不能推断极限不存在，需要使用其他方法 泰勒公式 思想：通过一个已知点和曲线的公式，用多项式去拟合该函数，多项式的阶越大，拟合越准确，但总有一个误差(皮亚诺余项/拉格朗日余项) 拉格朗日余项： 函数最大值最小值 闭区间上连续函数最大值最小值问题 找出驻点、不可导点、两段点的函数值 找出其中的最大最小值即可 在区间I上可导且仅有两个单调区间的最值问题 找到的点 判断左右导数符号 若二阶导数存在，可以根据二阶导符号判断 归结为求在的驻点的最值问题 若 的在区间上存在最小(大)值，通过求驻点方法求得 连续函数的极值点唯一的最值问题 曲率 弧微分 概念：有向弧段进行微分，即弧沿x方向的长度增长率。 公式： 曲率及计算公式 曲率：曲线弯曲程度的度量 角度：正比 弧长：反比 曲率公式： 特殊：圆的曲率为 参数方程曲率公式 曲率圆与曲率半径 曲率圆：在函数一点凹侧所作的与该点曲率相同的圆 曲率中心：曲率圆的圆心 曲率半径：曲率圆的半径 不定积分 不定积分的概念与性质 原函数与不定积分的概念 原函数：，那么就是的原函数 ==内涵：在该区间是可导的，在该区间是连续的== 原函数存在定理：连续函数一定有原函数 原函数要么没有，要么有无数多个 任意两个原函数的差值是常数 不定积分：==的原函数的集合称为不定积分==，记为 基本积分表 ​ 不定积分的线性性质 ==前提：在区间上存在原函数== 若的原函数存在，那么 换元积分法 第一类换元法 思想：凑微分，，再由t来替换被积变量 凑微分技巧 分母尽量简洁 三角不等式技巧 第二类换元法 思想：，需要单调可导，从而保证反函数存在且可导 分部积分法 思想： 有理函数的积分 有理函数的积分 有理函数：形如 有理函数的分解 根据分母是否可分来判断有理函数是否可以进行分解 可化为有理函数的积分 积分表的使用 题目训练 定积分 定积分的概念与性质 概念：和的极限， ==积分区间有限，被积函数有界== 可积性 充分条件 在闭区间连续就可积分 在闭区间有界，且只有有限个间断点就可积分 必要条件 可积在上有界 定积分的性质 线性性质： 区间可加性： ==c可以在内，也可以在外== 比较定理： 估值定理： 定积分中值定理：若函数在闭区间上连续， 微积分基本公式 积分上限函数及其导数 积分上限函数： 积分上限函数的导数： 结论一 如果函数在闭区间可积，那么是上的连续函数 若在连续，则积分上限函数是上的可导函数 结论二 若在上连续，那么积分上限函数是在上的一个原函数 不定积分与变限积分的关系 不定积分等于变限积分加一个不定常量 牛顿-莱布尼茨公式 ==意义：联系了定积分，原函数与不定积分，并通过原函数联系了微分学== 推论 设在连续，是在上的一个原函数则： 设在连续，是在上的一个原函数，且则： 奇偶函数与周期函数的积分性质 奇偶函数 奇函数在对称区间的积分值为0 偶函数在对称区间的积分值为2倍 若为奇函数，则为偶函数 若为偶函数，则为奇函数 周期函数 为周期函数的充要条件： 定积分换元法和分部积分法 题目训练 反常积分 本质：极限 无穷限反常积分 发散：极限不存在 收敛：极限存在 无界函数反常积分 瑕点：邻域内无界的点 反常积分的审敛法 f5ed4144-b7a8-4ef8-8385-08402e38bcf2函数 无穷限反常积分的审敛法 区间连续，若有上界，则反常积分收敛 比较审敛原理：区间连续，若收敛那么收敛 比较审敛法I 区间连续，，使得收敛 区间连续，，使得发散 绝对收敛的反常积分必定收敛 无界反常积分的审敛法 比较审敛法II 区间连续，，使得收敛 区间连续，，使得发散 极限审敛法则 区间连续，为瑕点，若存在，那么收敛，反之发散 函数 性质 定积分的应用 定积分在几何学上的应用 平面图形的面积 直角坐标系 极坐标系 体积 旋转体的体积 平行截面面积已知的立体的体积 平面曲线的弧长 定理：光滑曲线弧是可求长的 公式 参数方程： 直角坐标系： 极坐标系： 定积分在物理学上应用 变力沿直线作功 公式： 水压力 公式： 微分方程 微分方程是寻求问题函数表达式的工具。微分方程表示了目标函数及其导数之间的关系，通过解微分方程就能够找出目标函数表达式 微分方程基本概念 微分方程：凡是表示未知函数、未知函数的导数与自变量之间的关系的方程，叫做微分方程 微分方程的阶：最高阶导数的阶数 微分方程的通解：解得的微分方程中任意常数的个数等于微分方程的阶数1 初值条件：在通解基础上得到特解的条件 可分离变量的微分方程 一阶微分方程的对称形式： 可分离变量的微分方程：，即能够将变量分离至一边只含有x，另一边只含有y 齐次方程 齐次方程：能够化为形式的一阶微分方程 主要思想：通过对齐次方程进行变量替换，转化为可分离变量的微分方程 可化为齐次的方程：通过变量替换将非齐次方程的常数项消去从而转化为齐次方程即可用齐次方程解法求解 一阶线性微分方程 向量代数与空间解析几何 向量及其线性运算 向量相关概念 向量：由大小和方向两个因素唯一确定的量 向量夹角： 向量的模：向量的长度 单位向量：模=1 零向量：模=0 向量共面：向量的公共起点和各个终点在同一个平面 向量的线性运算 向量加减法：平行四边形法则，三角形法则 交换律 结合律 向量数乘：向量的伸缩变换 结合律 分配率 定理I：非零向量a，向量b平行于a的充分必要条件存在唯一的实数，使得 向量不等式 空间直角坐标系 思想：空间直角坐标系将向量、点和坐标联系起来，从而量化向量的计算 一般坐标系：符合右手规则 卦限：逆时针 利用坐标作向量的线性运算 由定理I结合坐标系推出：两向量平行 向量的模、方向角、投影 向量的模与两点间的距离公式 方向角与方向余弦 方向角：与三条坐标轴的夹角， 方向余弦：上面向量对应的三个值 向量在轴上的投影 本质：数量，记为或 性质 数量积 向量积 混合积 两向量的数量积 点乘： 交换律： 分配律： 结合律： 结论 向量垂直的充分必要条件为 两向量夹角余弦： 两向量的向量积 物理意义：力矩，物体产生转动的根本原因 叉乘： 反交换律： 分配律： 结合律： 向量的混合积 定义： 几何意义 若混合积为0，那么三向量共面，反之不共面。 混合积的绝对值表示构成平行六面体的体积 平面及其方程 曲面方程与空间曲线方程的概念 曲面方程： 曲线方程：两个曲面的交线，因此用一个方程组表示 平面的点法式方程 思想：法向量加上平面上一个点能唯一确定该平面 方程： 推导关键：数量积结论 平面的一般方程 方程： 特殊平面 D=0，表示通过原点的一个平面 A=0，表示平行于x轴的一个平面，其余同理 A=B=0，表示平行于xOy面的一个平面 两平面的夹角 定义：用两平面的法向量夹角，取锐角或直角 公式： 推论 两平面垂直： 两平面平行： 点到平面的距离公式： 空间直线及其方程 空间直线的一般方程 多元函数微分学 多元函数极限与连续性 二元函数的极限 二元函数极限：，从任何路径趋近 极限与无穷小的关系： 求二元函数极限常用方法：极限运算法则，放缩，变量替换 证明二元函数极限存在性：找出一条路径的极限不存在、找出两条路径的极限不同 二元函数的连续性 二元函数的连续性： 二元初等函数在定义域连续：x的初等函数与y的初等函数经过有限次四则运算，复合运算形成的函数 二元连续函数的性质 局部保号性 最大值最小值定理 介值定理 偏导数与全微分 偏导数概念与计算 定义： 偏导数的计算：一元函数导数的计算 可微性与全微分 可微性： 全微分： 充分条件：偏导数存在且连续 必要条件：偏导数存在， 性质之间关系 偏导次序 若混合偏导数都在定义域上连续，那么二阶混合偏导数的次序与结果无关 多元函数为常数的条件 多元函数为常数的条件：全微分恒等于0，或者说偏导数均为0 任意偏导数为0，即可将二元函数化为一元函数 多元函数的微分法则 全微分四则运算 已知：，均可微 ，，， 复合函数微分 多元函数与一元函数复合： 多元函数与多元函数复合： 一阶全微分的形式不变性： 隐函数微分法 方程的确定隐函数 一元隐函数存在定理 条件：函数在邻域内连续，且， 结论：在该邻域内，，且 计算方法：复合函数求导法则 二元隐函数存在定理 条件：函数在附近有连续偏导数，且 结论：在该邻域内，，且， 隐函数一阶偏导计算方法：复合函数求导法则、一阶全微分形式不变性、带入上述公式 隐函数二阶偏导计算方法：复合函数求导法则、对上述一阶结果继续求偏导 方程组确定的隐函数 一元隐函数、二元隐函数：克莱姆法则(从右往左看) 复合函数求导法则的应用 极坐标变换 多元函数极值问题 驻点概念：二元函数的驻点需要偏导数同时为0","tags":["系统学习","数学基础","高数"],"categories":["短期支线","考研"]},{"title":"Machine Learning","path":"/2023/04/02/Machine-Learning/","content":"机器学习 定义：从数据中提取出模型就是机器学习 类型 监督学习 无监督学习 回归问题：输出结果为一个数字 分类问题：输出结果为一个离散的类型 基本概念 输入变量：x 输出变量：y 样本数据量：m 单个训练样本： 第i个训练样本： 成本函数： 机器学习框架 通过数据集训练模型 数据模型预测值 成本函数可视化 等值线 线性回归模型 定义：用直线去拟合样本数据 梯度下降 适用范围：适用于大多数机器学习模型 思想：向着当前位置下降最快的方向走 子概念 学习率：沿当前梯度方向走的距离大小 凸函数：只有一个全局最小值的函数，即碗形图像 问题 学习率的确定：过高无法收敛，过低收敛速度太慢","tags":["系统学习","基础","机器学习"],"categories":["技术主线","机器学习"]},{"title":"Data Structure","path":"/2023/04/02/Data-Structure/","content":"数据结构 绪论 数据结构基本概念 基本概念和术语 数据：不是简单指数字，而是代指一切能够输入计算机内部的符号，并且该符号承载了信息以及事物的属性 数据元素：是一个整体结构，内部包含数据项，数据项是组成数据元素的最小单位。比如：学生（学号、姓名、班级） 数据对象：具有相同性质的数据元素的集合，如：数据库中元组和关系，元组是数据元素，关系是数据对象 数据类型 原子类型：不可再分的类型，如：基本数据类型int， double 结构类型：可再分的类型，如：struct 抽象数据类型：既有数据集合，又有对该集合操作的类型，如：类 数据结构 本质：==数据元素的集合==。集合内的数据元素之间存在特定的关系，如：树，图，链表等。简单理解，就是以什么形式(结构)组织数据元素，以适用于特定的应用场景 三要素：逻辑结构，物理结构(存储结构)，对数据元素的操作(数据运算) 数据结构三要素 逻辑结构：独立于物理存储和计算机的结构，是人为设计的抽象结构。主要分为线性结构，非线性结构 存储结构 顺序存储：物理上连续的存储，优点：占用空间小，可以随机存取 缺点：产生外部碎片 链式存储：物理上不一定连续的存储，优点：充分利用存储，不会产生碎片，缺点：指针占用额外空间，且只能顺序存取 索引存储：创建索引表辅助。优点：检索速度快，缺点：索引表占用额外空间，插入和删除需要修改索引表，增加额外开销 哈希存储：通过散列函数计算存储地址。优点：所有操作都很快。缺点：可能出现冲突，解决冲突会增加时间开销 复杂度度量 度量算法好坏的尺子 时间复杂度：随着输入规模的变化，最坏情况下的执行时间的变化趋势 渐近复杂度：关注大规模输入，重视总体变化趋势和增长速度 渐近上界()：正的常系数可视为1，低次项可省略。保守估计 渐近下界()：代表执行时间的下界。乐观估计 准确确界()：上界函数等于下界函数，代表对算法执行时间的准确估计。 复杂度分析 常数时间复杂度 对数时间复杂度 线性时间复杂度 多项式时间复杂度 指数时间复杂度 具有指数时间复杂度的算法一般没有实际意义 难解问题：没有多项式复杂度的问题 输入规模：严格定义为用以描述输入所需的空间规模 递归 分支转向是算法的灵魂 递归：函数(过程)的自我调用。简洁准确地描述问题 递归基：平凡情况。递归基能够保证递归算法的有穷性。 线性递归 简介：算法向深层递归调用，每一次至多调用自身一次，从而形成线性次序。 特征：线性递归问题，总可以分解为两个子问题，一个是独立的某个元素，另一个是和原问题结构一致的子问题。经过合并之后得到问题解。这类问题每次将问题规模缩减一个常数，最终抵达递归基，也称为减而治之 递归分析 递推方程：写出递推公式，确定平凡模式条件，结合数学归纳得出递归复杂度 递归跟踪：以图的形式刻画递归过程，从而分析递归复杂度 递归模式 多递归基 多向递归 二分递归 分而治之 将问题分解为若干规模更小的子问题 难点：需要对问题重新表述，保证子问题与原问题接口的形式一致 注意：对算法的渐近复杂度几乎无影响 分而治之适用条件 子问题划分和子问题合并这两个计算必须能够高效实现 各个子问题独立求解，并不相互依赖 优化策略 对于子问题有重合的问题，可以选择使用制表或者动态规划来进行优化 抽象数据类型(ADT) 外部特性与内部实现分离，提供一致且标准的对外接口 向量 物理存储顺序与逻辑顺序相同的数据结构 从数组到向量 向量：根据面向对象思想，对线性数组的抽象与泛化。其中的数据元素不再只是基本数据类型，也不保证每个元素都有某个数值 接口 操作接口 构造与析构 指导计算机创建和回收对象 构造函数：告诉计算机如何配置一个对象的内存 析构函数：告诉计算机如何回收一个对象的内存 动态空间管理 高效利用空间 静态空间管理：在向量的生命周期内无法改变容量 动态空间管理：在向量的生命周期内容量可以动态变化 可扩充向量：一种动态空间管理方法。申请新的更大的内存，然后复制数据，回收原来的内存 基本问题 新容量取多少：2倍原内存 分摊分析 将某些时间复杂度不确定的操作，将其所消耗的时间分摊到所有操作上 常规向量 直接引用元素 template &lt;typename T&gt; T&amp; Vector&lt;T&gt;::operator[](rank i) {return _elem[i];} 置乱算法 template &lt;typename T&gt; T&amp; Vector&lt;T&gt;::permute(rank lo, rank hi){ T* base = _elem + lo; for(int i = hi - lo; i &gt; 0; i--){ swap(base[i-1], base[rand() % i]); } } 顺序查找 template &lt;typename T&gt; rank Vector&lt;T&gt;::find(const T&amp; e, rank lo, rank hi) const{ while(lo &lt; hi-- &amp;&amp; e != _elem[hi]); return hi &lt; lo ? -1 : hi; } 插入 template &lt;typename T&gt; rank Vector&lt;T&gt;::insert(const T&amp; e, rank r){ expand(); // 必要时扩容 for(int i = _size; i &gt; r; i--) _elem[i] = _elem[i-1]; _elem[r] = e; _size++; return r; } 时间复杂度： 删除 template &lt;typename T&gt; rank Vector&lt;T&gt;::remove(rank lo, rank hi){ if(lo == hi) return 0; while(hi &lt; _size) _elem[lo++] = _elem[hi++]; _size = lo; shrink(); return hi - lo; } 时间复杂度： 唯一化 template &lt;typename T&gt; int Vector&lt;T&gt;::deduplicate(rank lo, rank hi) { int old_size = _size; if(lo == hi) return 0; for(int i = 1; i &lt; hi;){ find(_elem[i], lo, i) &lt; 0 ? i++ : remove(i); } return old_size - _size; } 有序向量 唯一化 template &lt;typename T&gt; int Vector&lt;T&gt;::deduplicate(){ int i = 0, j = 0; while(++j &lt; _size) if(_elem[j] != _elem[i]) _elem[++i] = _elem[j]; _size = i; return j - i; } 时间复杂度： 查找 二分查找 版本A template &lt;typename T&gt; rank Vector&lt;T&gt;::search(const T&amp; e, rank lo, rank hi) const{ while(lo &lt; hi) { rank mid = (lo + hi) &gt;&gt; 1; if(_elem[mid] == e) return mid; else if(_elem[mid] &lt; e) lo = mid + 1; else hi = mid; } return -1; } 版本B template &lt;typename T&gt; rank Vector&lt;T&gt;::search(const T&amp; e, rank lo, rank hi) const{ while(1 &lt; hi - lo) { rank mid = (lo + hi) &gt;&gt; 1; if(e &lt; _elem[mid]) hi = mid; else lo = mid; } return _elem[lo] == e ? lo : -1; } 版本C template &lt;typename T&gt; rank Vector&lt;T&gt;::Search(const T&amp; e, rank lo, rank hi){ while(lo &lt; hi) { rank mid = (hi + lo) &gt;&gt; 1; if(e &lt; _elem[mid]) hi = mid : lo = mid + 1; } return --lo; } 斐波那契查找 template &lt;typename T&gt; rank Vector&lt;T&gt;::fib_search(const T&amp; e, rank lo, rank hi) { Fib fib(hi - lo); while(lo &lt; hi){ while(fib.get() &gt; hi - lo) mid = fib.pre(); if(e &lt; _elem[mid]) hi = mid; else if(e &gt; _elem[mid]) lo = mid + 1; else return mid; } return -1; } 排序与下界 排序及其分类 数据处理规模或存储特点：外部排序和内部排序 数据的输入形式：离线和在线 随机策略：确定式和随机式 比较树 定义：根绝算法的比较与比对流程将算法抽象为一棵比较树 作用：估计基于比较式算法的复杂度下界 方法：根据算法可能的输出结果数量，反推比较树的最大高度，从而估计算法的复杂度下界 排序器 稳定性：排序完成后，值相同的元素在向量中的相对位置不发生改变 冒泡排序 template &lt;typename T&gt; rank Vector&lt;T&gt;::bubble_sort(rank lo, rank hi){ while(!bubble(lo, hi--)); } template &lt;typename T&gt; rank Vector&lt;T&gt;::bubble(rank lo, rank hi){ bool sorted = true; while(++lo &lt; hi){ if(_elem[lo - 1] &gt; _elem[i]){ sorted = false; swap(_elem[i], _elem[i-1]); } } return sorted; } 冒泡排序算法具有稳定性 归并排序 template &lt;typename T&gt; void Vector&lt;T&gt;::merge_sort(rank lo, rank hi) { if(hi - lo &lt; 2) return ; mid = (lo + hi) &gt;&gt; 1; merge_sort(lo, mid); merge_sort(mid, hi); merge(lo, mid, hi); } template &lt;typename T&gt; void Vector&lt;T&gt;::merge(rank lo, rank mid, rank hi) { T* A = _elem + lo; int lb = mid - lo; T* B = new T[lb]; for(int i = 0; i &lt; hi - lo; i++) B[i] = A[i]; int lc = hi - mid; T* C = _elem + mid; for(int i = 0, j = 0, k = 0; (i &lt; lb || j &lt; lc);){ if(i &lt; lb &amp;&amp; (!(j &lt; lc) || B[i] &lt;= C[j])) A[k++] = B[i++]; else if(j &lt; lc &amp;&amp; (!(i &lt; lb) || C[j] &lt; B[i])) A[k++] = C[j++]; } delete[] B; } 第一个能够在最坏情况下保证复杂度的确定性算法 时间复杂度：，即使在链表上也能保证这个时间复杂度 其中merge()时间复杂度为 列表 熟知的代表是链表，逻辑顺序和物理顺序不一定一致的数据结构 无序列表 头尾节点 作为哨兵存在，对外不可见。头节点指向首节点，尾节点的前驱指向末节点。 默认构造方法 template &lt;typename T&gt; void List&lt;T&gt;::init(){ header = new ListNode&lt;T&gt;; tail = new ListNode&lt;T&gt;; header-&gt;succ = tail; header-&gt;pred = nullptr; tail-&gt;pred = header; tail-&gt;succ = nullptr; _size = 0; } 位置代替秩 #define ListNodePos(T) ListNode&lt;T&gt;* template &lt;typename T&gt; T&amp; List&lt;T&gt;::operator[](rank r) const { ListNodePos(T) p = first(); while(r--) p = p-&gt;succ; return p-&gt;data; } 查找 #define ListNodePos(T) ListNode&lt;T&gt;* template &lt;typename T&gt; ListNodePos(T) List&lt;T&gt;::find(T const&amp;e, int n, ListNodePos(T) p) const { while(n--) if(e == (p = p-&gt;pred)-&gt;data) return p; return nullptr; } 插入 #define ListNodePos(T) ListNode&lt;T&gt;* template &lt;typename T&gt; ListNodePos(T) List&lt;T&gt;::insert_as_first(T const&amp;e){ _size++; return header-&gt;insert_as_succ(e); } template &lt;typename T&gt; ListNodePos(T) List&lt;T&gt;::insert_as_Last(T const&amp;e){ _size++; return tail-&gt;insert_as_pred(e); } template &lt;typename T&gt; ListNodePos(T) List&lt;T&gt;::insert_before(T const&amp;e, ListNodePos(T) p){ _size++; return p-&gt;insert_as_pred(e); } template &lt;typename T&gt; ListNodePos(T) List&lt;T&gt;::insert_after(T const&amp;e, ListNodePos(T) p){ _size++; return p-&gt;insert_as_succ(e); } 其中辅助函数为节点本身提供的插入函数 #define ListNodePos(T) ListNode&lt;T&gt;* template &lt;typename T&gt; ListNodePos(T) ListNode&lt;T&gt;::insert_as_succ(T const&amp;e){ ListNode&lt;T&gt; new_node = new ListNode&lt;T&gt;(e, pred, this); pred-&gt;succ = new_node; this-&gt;pred = new_node; return new_node; } template &lt;typename T&gt; ListNodePos(T) ListNode&lt;T&gt;::insert_as_pred(T const&amp;e){ ListNode&lt;T&gt; new_node = new ListNode&lt;T&gt;(e, this, succ); this-&gt;succ = new_node; succ-&gt;pred = new_node; return new_node; } 复制构造函数 #define ListNodePos(T) ListNode&lt;T&gt;* template &lt;typename T&gt; void List&lt;T&gt;::copy_nodes(ListNodePos(T) p, int n){ init(); while(n--) { insert_as_last(p-&gt;data); p = p-&gt;succ;} } template &lt;typename T&gt; List&lt;T&gt;::List(ListNodePos(T) p, int n) { copy_nodes(p, n); } template &lt;typename T&gt; List&lt;T&gt;::List(List&lt;T&gt; l) { copy_nodes(l.first(), l._size); } template &lt;typename T&gt; List&lt;T&gt;::List(List&lt;T&gt; l, rank r, int n) { copy_nodes(l[r], n); } 删除 template &lt;typename T&gt; T List&lt;T&gt;::remove(ListNodePos(T) p) { T e = p-&gt;data; (p-&gt;pred)-&gt;succ = p-&gt;succ; (p-&gt;succ)-&gt;pred = p-&gt;pred; delete p; _size--; return e; }","tags":["系统学习","数据结构","基础"],"categories":["技术主线","数据结构"]},{"title":"Data Mining","path":"/2023/04/02/Data-Mining/","content":"数据挖掘 引论 什么是数据挖掘 数据中的知识发现（Knowledge discover in data） 数据挖掘的基本步骤： 数据清理： 删除噪声和不一致的数据 数据集成： 将多个数据源组合在一起 数据选择： 从数据库中提取出与分析任务相关的数据 数据变换： 通过汇总或聚集操作，将数据变换和统一为适合挖掘的形式 数据挖掘： 用智能方法提取数据模式 模式评估： 用某种兴趣度度量，识别真正有趣的模式 知识表示： 使用可视化和知识表示技术，向用户提供挖掘的知识 挖掘什么类型的数据 数据库数据 数据仓库 事务数据 挖掘什么类型的模式 特征化与区分 频繁模式，关联和相关性 预测分析：分类与回归 聚类分析 离群点分析 所有模式都是有趣的么？ **有趣：**非平凡的，蕴含的，潜在有用的，先前未知的 度量： 客观度量 支持度 置信度 主观度量 使用什么技术 统计学 机器学习 监督学习 无监督学习 半监督学习 主动学习 认识数据 数据对象与属性类型 **属性：**是一个数据字段，表示数据对象的一个特征。 标称属性： 一些符号或事物的名称。被视为分类的，无序的，枚举的。 二元属性：只有两个状态0或1，0表示不出现，1表示出现 对称二元属性：两种状态具有同等价值，如男性，女性 非对称二元属性：两种状态价值不同，比如病毒检测结果阳性更具价值 序数属性：值域元素之间存在有意义的序或者秩，但是排序相邻的元素之间的差值是未知的。如：大杯，中杯，小杯，我们并不知道大杯比中杯大多少，只知道这个排序。 数值属性：定量的属性，可以用整数或者实数表示，是可以区间标度的或比率标度的 区间标度：例如温度，可以说一个温度比另外一个温度高多少度。但是华氏度和摄氏度都不能说一个温度比另外一个温度高多少倍。它们只是有相同的单位尺度，但没有绝对的零点 比率标度：具有固定零点的数值属性。如：公司员工数量，货币量等等 离散属性与连续属性 数据的基本统计描述 中心度量趋势 均值： 普通均值 加权均值 截尾均值：去掉极高和极低的数据的均值 中位数： 奇数个数据： 偶数个数据： 近似中位数： 众数 一个数据集中可能有多个众数 如果每个数据仅出现一次，那么该数据集没有众数 中列数：一个数据集最大值和最小值的平均值 数据分布： 对称：中位数等于众数 非对称： 正倾斜：中位数大于众数 负倾斜：中位数小于众数 度量数据散布 极差：数据集最大值和最小值的差值 四分位数：用3个数据点将数据集划分为大小相等的4个子集，这三个数据点为四分位数。第二个四分位数为中位数。 四分位数极差：第三个四分位数减第一个四分位数，即：，表示数据中间一半覆盖的范围。 盒图： 盒体上边界为： , 下边界为： 上胡须延长至：极大值，下胡须延长至：极小值 离散点：超过四分位数1.5*IQR的数据，单独画出。 方差和标准差： 基本统计描述的图形表示 分位数图 纵轴：属性的数据范围 横轴： 分位数-分位数图 直方图 散点图 数据可视化 数据可视化的意义：通过图形清晰有效的表示数据 度量数据的相似性和相异性 数据矩阵和相异性矩阵 数据矩阵： 矩阵，n个对象，p个属性 相异性矩阵： 矩阵， 其中元素代表相异性度量 相似性度量： 标称属性的邻近性度量：, 其中p为标称属性个数，m为两对象在相同的标称属性上值相同的个数。 二元属性的邻近性度量 对称属性： 非对称属性：, 因为负负属性不重要，所以直接去掉 数值属性的邻近性度量：闵可夫斯基距离 欧几里得距离：又称L2范数 曼哈顿距离：又称L1范数 上确界距离：, 即最大差值，也称一致范数 序数属性的邻近性度量：, 将序数属性转化为数值属性进行计算 混合类型属性的相异性 只要有一个对象的属性值缺失，则,否则 f为数值属性，则： f是标称或二元，则若,则，反之为1 序数的就转化为数值属性处理即可 余弦相似性：针对文档等稀疏的词向量 数据预处理 数据预处理概述 数据质量：为什么要数据预处理 准确性： 数据是没有错误的 完整性：数据属性值是完整的 一致性：数据记录之间是没有冲突的 时效性：时间的影响 可信性：挖掘者是否信任该数据 可解释性：能知道怎么解释这个数据的意义 数据预处理的主要任务（作用） 数据清理 数据集成 数据规约 数据变换 数据清理 缺失值 忽略整个元组 人工填写 全局常量填写 中心度量填写 同一类元组的中位数或均值填充(当数据是倾斜的选择中位数) 最可能值填写：通过回归，贝叶斯，决策树等方法 噪声 分箱 箱均值光滑 箱中位数光滑 箱边界光滑 回归：通过函数拟合 离群点分析：聚类分析等方法 数据清理作为一个过程 偏差检测 元数据：属性的数据类型和定义域，均值，中位数，倾斜还是对称 字段过载 唯一性规则：值域没有重复元素 连续性规则 空值规则 数据集成 实体识别问题：两个数据源进行属性匹配，如：cus_id与cus_num 冗余和相关性分析 标称数据采用卡方检验： 数值属性的相关系数 数值属性协方差： 数据规约 数据规约概述 维规约：减少属性个数，如：小波变换，主成分分析 数量规约：用较小的数据代替元数据，如：直方图，聚类，抽样 数据压缩 有损：近似重构原数据 无损：重构后不损失信息 数据变换与数据离散化 数据变换策略概述 光滑：去掉噪声，分箱，回归，聚类 属性构造：根据已有属性，构造新的属性 聚集：对数据进行汇总和聚集，如根据月销售量聚集成年销售量 规范化： 将数据缩放进一个小区间内 离散化：数值属性的原始值用区间或标签替代 分箱 直方图 聚类、决策树、相关分析 有标称属性产生概念分层 规范化数据 最大最小规范化：映射到目标区间。 z分数规范化： 小数标定规范化：，其中j为使v最大绝对值小于1的最小整数 挖掘频繁模式、关联和相关性 性质是什么啊。反正apple算法都是重点啊，它步骤是什么啊？如何得到关联规则啊？这个这个他的优缺点啊，然后这个这个啊改进的一些思路、一些基本思想，有什么缺陷啊等等等等等说法 这个是呃第六章啊最重要的算法，没有之一啊，然后其次是f算法，它跟apple算法的区别，它的思想、它的步骤，对吧？ 这个也是有给大家布置的作业的啊优缺点啊，特别是什么？一个做这个地方我们有一个非常重要的概念，可伸缩性，对吧？所以上测试我们也有这个题目啊，可伸缩性啊。好，然后呢就是使用垂直模式挖掘的好处啊，以及使用锤子模式那种方式很简单，对吧？ 我们一共就两页PPT啊，很简单很容易掌握，对吧？ 什么时候用垂直模式挖掘它有啥好处？好，以及第六章最后一个部分模式评估，我们给大家介绍五个兴趣度度量啊，哪些是零不变的。什么叫零不变性啊？啊，不平衡笔是用来干嘛的。对吧？然后学会能够用他们来评估。好，这个是第六章、第七章。 基本概念 频繁模式：频繁出现在数据集中的模式(项集，子序列，子结构) 关联规则： 支持度：表示所有事务中A和B同时出现的占比，即： 置信度：表示事务中A和B同时出现的次数/事务中出现A的次数，即： 强规则：同时满足最小支持度阈值和最小置信度阈值。 绝对支持度：由频数作为支持度 频繁项集：出现次数超过最小支持度计数 挖掘关联规则的步骤 找出所有频繁项集 由频繁项集产生强关联规则 闭：没有真超集能够和他有相同的支持度计数 闭频繁项集：闭+频繁 极大频繁项集：没有超集是频繁项集 可伸缩性：==随着数据量的增加，数据挖掘算法的运行时间必须是可遇记的，短的和可以被接受的==。 Aprior算法 先验性质 ==频繁项集的所有非空子集也一定是频繁的== ==非频繁项集的的超集也一定是非频繁的== 步骤 连接步 剪枝步 ==缺陷：== 仍然可能产生大量候选集 可能重复扫描数据库 候选支持度计数工作量繁重 由频繁项集产生关联规则 计算置信度即可 提高Apriori算法的效率 基于散列，桶计数小于最小支持度计数的直接剔除 事务压缩 划分 抽样 频繁模式增长 对于挖掘长的频繁模式和短的频繁模式，它都具有有效性和可伸缩性，并且比Apriori算法快一个数量级。 不产生候选项 压缩数据库 不重复扫描整个数据库 哪些模式是有趣的 提升度： 若提升度大于1，则两者正相关 若提升度小于1，则两者负相关 若提升度等于1，则两者相互独立 卡方相关性分析：观测值期望值期望值，期望值 全置信度： 最大置信度： Kulczynski度量： 余弦度量： ==所有以上度量都满足0～1，且值越大联系越紧密== 零事务：不包含被考察的项集的事务。 ==除了提升度和卡方相关分析外，其余度量都是零不变度量，因为它们不受零事务影响== 高级模式挖掘 基本概念 ==负模式：如果项集X和Y都是频繁的，但很少一起出现，则项集X与Y是负相关的，且为负模式== ==稀有模式：支持度低于用户指定的支持度阈值的模式== 分类：基本概念 有监督学习，无监督学习概念 分类，数字预测概念 分类的步骤 决策树和朴素贝叶斯 过拟合 基本概念 预测问题 数值预测：回归分析是最常用的方法，例：预测一位顾客将在购物期间花多少钱。构造的模型预测一个连续值函数或有序值，这种模型称为预测器 分类：构造模型或者分类器来预测类标号 学习阶段：构建分类模型 分类阶段：使用模型预测给定数据的类标号 类标号属性：离散、无序 监督学习：分类器的学习在被告知每个训练元组属于哪个类的“监督”下学习 无监督学习：每个元组的类标号是未知的，且要学习的类的个数事先也可能是未知的 过拟合： 准确率：分类器正确分类的测试集元组所占的百分比 正元组：感兴趣的主要类的元组 负元组：其他元组 决策树归纳 基本算法： 三个参数 数据分区：元组集合 属性列表：元组属性的列表 属性选择度量：基尼指数、信息增益等 树从单个节点N开始 如果D中所有元组都同一类，则节点N变成树叶，并用该类标记它 否则调用属性选择度量来指定分裂属性和分裂点 节点N利用分裂准则标记作为节点上测试，对于分裂准则的每个输出，生成一个分支，分支中的元素由D根据分裂准则划分生成 属性A是离散值：划分准则就是某几个离散值 属性A是连续值：根据分裂点划分为两个部分，生成两个分支 属性A是离散值却必须生成二叉树：分为yes，no集合 对于结果分区递归调用函数，生成决策树。 终止条件： 分区中所有元组都属于同一类 没有剩余属性可供划分元组，使用多数表决 分支没有元组，使用D中的多数类创建一个树叶 返回决策树 属性选择度量 信息增益——越大越好 信息熵： 通过属性划分后的信息增益： 解释：通过对A的分裂后，未知信息减少了多少 划分后的信息总量： 如果处理的是连续的值那么需要选择分裂点，排序后人为划分：分裂点是两个连续值的中间值，分裂的分支数一定为2 缺点：偏向选择包含大量值的属性 增益率——越大越好 解释：以划分属性分类来计算信息熵，原来的是以最终的类别 基尼指数——越小越好 代表不纯度；代表划分子集中属于最终类的百分比； 离散属性：需要将属性划分为2个子集，考虑所有划分 **连续属性：**处理方法和信息增益一致 要求越小越好，越大越好 树剪枝 先剪枝：可以使用统计显著性、信息增益、基尼指数等度量划分的优劣，如果划分节点时低于阈值就停止划分 后剪枝：完全生长的树剪去子树。 **CART的代价复杂度剪枝算法：**用剪枝集评估代价复杂度，最小化代价复杂度为目标 C4.5悲观剪枝：不使用剪枝集而使用训练集，基于认为训练集评估准确率或错误率过于乐观 可伸缩性与决策树归纳 RainForest BOAT：树构造的自助乐观算法 **思想：**取样，精度换速度 贝叶斯分类方法 贝叶斯定理 后验概率：已知某些关于这件事条件，发生这事情的概率 先验概率：一切未知的情况下，这件事发生的概率 朴素贝叶斯分类 使后验概率最大化 类条件独立假设 如果为连续值属性： 步骤 计算每个分类的先验概率 计算不同分类下各个属性的后验概率 计算给定条件的后验概率 计算先验概率与给定条件后验概率的乘积，选择最大的分类作为最终分类 若存在零概率：拉普拉斯校准，在相应属性每个值各添加一个元组 模型评估与选择 评估分类器性能的度量 准确率： 错误率： 灵敏性,召回率： 特效性： F度量： 度量： 保持方法和随机二次抽样 交叉验证 分类：高级方法 基本概念 ==后向传播：即通过类实例标号，不断修正参数，从输出层到第一个隐藏层，最终使参数收敛== ==贝叶斯信念网络：解决朴素贝叶斯类条件独立的问题== 支持向量机：通过非线性映射，将数据映射到更高维，搜索最佳分离超平面 聚类分析：基本概念和方法 基本概念 聚类：把数据对象划分为多个组或簇的过程，使得簇内的对象具有很高的相似性，但与其他簇中的对象很不相似 聚类分析 对聚类分析的要求 可伸缩性 处理不同属性类型的能力 发现任意形状的簇 对于确定输入参数的领域知识的要求 处理噪声数据的能力 增量聚类和对输入次序不敏感 聚类高维数据的能力 基于约束的聚类 可解释性和可用性 划分准则 簇的分离性 相似性度量 聚类空间 基本聚类方法概述 划分方法 给定一个n个对象的集合，划分方法构建数据的k个分区，其中每个分区代表一个簇， 大部分划分是基于距离的，采用迭代重定位的方法 迭代重定位：把一个对象移动到另外一个组来改进划分。 缺点：计算量极大，相当于枚举，基于距离的方法只能发现球状簇 层次方法 凝聚：自底向上，最初将每个对象单独作为一个组，然后逐次合并相近的组或对象直到所有的组合并为一个组，或者满足某个终止条件 分裂：自顶向下，开始将所有对象放入一个组，每次划分为一个更小的簇，或者满足某个终止条件 缺点：一个步骤完成，就不能撤销 基于密度方法 思想：只要邻域中的密度超过某个阈值就继续增长 基于网格 划分方法 K-means：基于形心的技术 工作流程 首先随机地选择k个对象，每个对象代表一个簇的初始均值或中心 对剩下的每个对象，根据其与各个簇中心的欧式距离，分配到最近的簇 利用新分配到的对象，重新计算新的中心不断迭代 缺点 不能保证k-means收敛于全局最优解，在实践中，可能会选择不同的初始簇中心运行k-means 需要预先定义k值，即多少个簇 严重受离群点影响 K-中心点：一种基于代表对象的技术 思想：不用对象的均值作为参照点，而是用一个实际对象代表簇 误差标准： 层次方法 凝聚的与分类的层次聚类 凝聚 每个簇都用簇中所有对象代表 两个簇的相似度用不同簇中最近的数据点对的相似度来度量 算法方法的距离度量 最小距离：两个簇中距离最近的两个点的距离 如果最近的两个簇之间的距离超过阈值，聚类终止，则称其为单连接算法 最大距离：两个簇中距离最远的两个点的距离 如果当最近的两个簇之间的最大距离超过阈值，聚类终止，则称其为全来接算法 如果真实的簇较为紧凑且大小近似相等，则这种方法将会产生高质量的簇，否则毫无意义 均值距离：中心点的距离 平均距离：计算两个簇中所有点组合的距离均值 BIRCH：使用聚类特征树的多阶段聚类 应用场景：大量数值数据聚类 优点：可伸缩性，可以撤销先前步骤的工作 Chameleon：使用动态建模的多阶段层次聚类 思想：动态建模确定一对簇的相似度 优点：不用依赖于一个静态的，用户提供的模型，能够自适应 概率层次聚类 思想：通过概率模型度量簇之间的距离，克服以上某些缺点 基于密度的方法 DBSCAN：一种基于高密度连通区域的基于密度的聚类 核心对象：邻域内的对象数量大于等于阈值 邻域密度：邻域内的对象数度量 直接密度可达：该点在核心对象点邻域中 密度可达：直接密度可达传递，出发点和中间点必须是核心对象 密度相连：两个中心能够从同一个点密度可达 基于网格的方法 思想：将对象空间量化为有限数目的单元，这些单元形成了网格结构，所有的聚类操作都在该结构上进行 优点：处理速度快，处理速度进依赖于量化空间中每一维上的单元数 聚类评估 高级聚类分析 离群点检测 什么是离终点啊。离群点和其他的一些相似概念有什么区别啊？离群点点的定义啊，经典的三种离群点的分类啊，离群点检测是个什么概念啊？这样一些啊。 然后呢就是四种离群点检测的方法，他们的原理，他们的假设，特别是他们的假设是什么？原理是什么？特点是什么啊，优缺点是什么啊，然后有监督、无监督从另外一个角度来划分，有监督、无监督、半监督这种离群点检测啊，他们的概念、特点啊是什么啊？ 啊，优势。优缺点，优势是什么？适用于什么样的场景。对吧？啊，然后最后就是对于高危的触点它的挑战是什么？它的困难是什么？啊，基本思路是什么啊？挖掘情景的清点和集体的景点啊，他的思路是什么啊。这个这个对困难在什么地方？对吧？ 基本概念 离群点：显著不同于其他数据对象的数据对象 离群点和离群点分析 离群点的类型 全局离群点 显著的偏离数据中的其他对象 情景离群点 关于对象的特定情景，显著地偏离其他对象。 比如夏天-1度 集体离群点 单个点或许不是离群点，但是这群点的集合是异常点 离群点检测方法 监督半监督无监督方法 监督方法：专家标记基础数据的样本 缺点： 离群点总体数量少，专家标记样本可能不足以代表离群点分 无监督方法 假设：正常对象在某种程度上是聚类的 缺点：不属于簇的可能是噪声而不是离群点，开销大 半监督方法 高维数据中的离群点检测 挑战 离群点的解释 数据的稀疏性 数据子空间 关于维度的可伸缩性 Question 数据挖掘的功能是什么 数据挖掘的主要问题和挑战是什么 各个图的优缺点，适用场景是什么 数据可视化的意义 协方差等于0可能相关也可能无关 可伸缩性是什么 垂直模式挖掘的好处，什么时候用","tags":["系统学习","数据挖掘引论"],"categories":["短期支线","大学课程"]},{"title":"MIT 6.S081","path":"/2023/03/16/MIT-6-S081/","content":"MIT 6.S081 配置问题 本地环境 设备：MacBook Air 2020 ( m1 芯片 ) 编译器：Apple clang version 14.0.0 (clang-1400.0.29.202) 问题清单 无穷递归 问题描述：error: infinite recursion detected [-Werror=infinite-recursion] 解决方法：在sh.c中runcmd函数签名上添加*_attribute_((noreturn))* 理论部分 陷阱和系统调用 陷阱机制：内核通过对特定控制寄存器进行写操作，CPU利用这些寄存器的信息处理陷阱 特定控制寄存器 STVEC：保存陷阱处理代码的地址 SEPC：保存进入陷阱前的PC SCAUSE：保存陷阱的类型 SSCRATCH： SSTATUS：分为SIE位、SPP位，前者控制中断使能，后者表示陷阱来自内核态还是用户态 以上这些特定控制寄存器只能在特权级进行修改 大致流程 禁用中断(SIE位清零) 保存PC至SEPC 保存发生陷阱时的特权级别(SPP位) 设置scause(反应陷阱的原因) 设置CPU到内核态 将STVEC复制到PC 执行新PC 注意事项：目前仅仅在用户态做了很少的工作，即没有切换页表，也没有切换内核堆栈，更没有保存任何寄存器。 来自用户态的陷阱 高视角下用户态陷阱的执行过程：uservecusertrapusertrapsetuserret 蹦床页面：由于最初并未对页表进行切换，因此STEVC必须同时在内核页表和用户进程页表中进行有效映射 该页面被映射到每个进程的地址空间的最高地址处 保存现场：保存进入陷阱前的32个寄存器状态，此时需要SSCRATCH辅助保存，因为此时没有空闲通用寄存器 将与SSCRATCH交换数据，在交换之后内部存储的是Trampframe的基址 TRAMPFRAME 映射到每个进程地址空间蹦床页面下方，并设置为特权级可访问 用于存储进入陷阱前状态以及返回值，此页面由内核维护，用户进程不能访问 存放着当前进程的内核堆栈地址 存放着内核页表的地址 CPU标示号 陷阱处理C函数地址 USERTRAP：确定造成陷阱的原因，对陷阱处理，并返回 首先将STVEC更改为kernelvec，这样在内核中发生的TRAP就是被kernelvec处理 然后保存SEPC，因为TRAP过程中可能会调用yield（时钟中断）函数切换到另外一个进程的内核线程，该线程可能会返回用户空间，这个过程将会改变SEPC的值。 根据TRAP的不同类型分别处理 将程序计数器加4：当前的程序计数器指向ecall，我们希望TRAP执行完后执行ecall的下一条指令 最后检查该设备中断是否是时钟中断，若是则执行yield函数放弃CPU 返回用户空间 usertrapret：配置TRAPFRAME以处理下一次来自用户空间的TRAP。包括配置STVEC为uservec，配置SEPC为之前的程序计数器，配置uservec依赖的各种参数(kernel_pgtbl...)，最后调用userret userret：接收TRAPFRAME和PGTBL参数。首先将TRAPFRAME中保存的与SSCRATCH交换，交换后存储的是TRAPFRAME的地址，以其为基址将TRAPFRAME中保存的状态恢复到CPU中的寄存器中。最后与SSCRATCH交换，以便下一次TRAP发生时，SSCRATCH保存着该进程的TRAPFRAME的地址 来自内核态的陷阱 保存现场：kernelvec首先将寄存器状态压入该线程的内核堆栈，以便当TRAP返回的时候从堆栈恢复现场，接着调用kerneltrap 陷阱类型：来自内核态的陷阱的类型分为设备中断和异常。若是设备中断，则会检查并执行相应的例程。若是异常，操作系统则会崩溃 定时器中断是设备中断中比较特殊的存在。当前线程会放弃CPU，在将来某个时间点通过堆栈恢复状态继续执行。 返回：复制SEPC到PC，并恢复现场。 缺页异常 一种辅助实现懒加载的机制 处理缺页异常 引发缺页异常的虚拟地址：存储在STVAL寄存器中 引发缺页异常的原因：存储在SCAUSE寄存器中 引发缺页异常的指令地址：存储在SEPC寄存器中 利用以上三个寄存器的信息，就能知道进入内核后如何处理缺页异常，并知道回到用户态时需要重新执行的指令的地址。 懒内存分配机制：在进程申请内存的时候，并不立即分配内存并映射到该进程的地址空间，而是仅对该进程的栈顶指针进行修改，等到进程真正使用申请的内存时，通过触发缺页错误进入内核从而真正分配物理内存。 未使用时0填充机制 地址空间：进程地址空间有三个区域，其中text区域存放指令，data区域存放初始化的全局变量，BSS区域存放未初始化或初始化为0的全局变量 原理：将BSS区域的所有页面全部映射到一个全为0的物理页面，从而节省程序启动时的物理内存分配。将BSS区域所有页面设置为只读，通过触发缺页异常进入内核真正分配一个全0的物理内存，并重新执行指令。 写时复制机制：fork系统调用创建子进程，子进程的页表和父进程页表共享物理内存，将子进程与父进程的PTES均设置为只读，只有当两者中任一个进程对内存有write时才会分配并复制内存，并将该页面映射到子进程。从而优化fork后立马调用exec的场景。 按需分配页面：在加载进程时，只加载部分指令到内存，其余PTES通过缺页异常来懒加载。涉及到页面置换问题。 内存映射文件 系统调用：mmap()从文件描述符对应的文件的偏移量的位置开始，映射长度为len的内容到虚拟内存地址VA，同时我们需要加上一些保护，比如只读或者读写。 原理：将完整或者部分文件加载到内存中，这样就可以通过内存地址相关的load或者store指令来操纵文件。 中断和设备驱动 中断是硬件请求CPU处理的机制，驱动是操作系统中与设备交互的程序 硬件 外设：在主板上的各种芯片，以及可以连接到主板的各种设备 PLIC：中断管理设备，接收多个设备的中断信号将其映射为对应的中断号，然后将中断号传给CPU核心，CPU核心根据中断号执行相应的中断处理程序。 PLIC会通知当前有一个待处理的中断 其中一个CPU核会Claim接收中断，这样PLIC就不会把中断发给其他的CPU处理 CPU核处理完中断之后，CPU会通知PLIC PLIC将不再保存中断的信息 中断 仍然利用TRAP机制实现，与系统调用和缺页异常采用同一种机制实现。但是仍然存在一些差异 异步：中断和当前运行在CPU上的进程没有任何关系。而系统调用需要保存进程上下文。 并发：产生中断的外设和CPU是相互独立，同时运行的，是真正的并行运行。例如网卡和CPU 对设备编程：中断需要对设备进行编程，控制设备操作。 所有外设都连接到CPU上，通过PLIC(Platform Level Interrupt Control)来管理设备中断，路由中断到某个CPU核心 中断相关寄存器 SIE：不同的位针对不同中断的使能。分别针对外部设备中断，软件中断使能以及定时器中断使能。 SSTATUS：控制所有中断的使能。SIE和SSTATUS在每个CPU核中都有。 SIP：发生中断时，保存中断类型。 SCAUSE：保存陷阱的类型 STVEC：保存程序计数器，保证中断、缺页异常或者系统调用结束后，程序能够继续正常执行。 驱动 管理内核的代码就是驱动，驱动都在内核中 驱动的架构一般分为top和bottom两个部分，其中bottom一般是中断处理程序，当某个CPU核心接收中断就会调用该程序。top是提供给用户进程或内核其他部分程序调用的接口，例如read()和write() 驱动中包含存储数据的buffer，无论是top还是bottom中的程序都可以对其进行读写。但是由于bottom中的interrupt handler使用内核页表，因为中断例程是独立于进程的，所以不能随意读写数据。 设备编程：通过I/O端口映射，主板厂商将设备映射到物理地址上，便可以用与读写内存相同的方式对设备进行编程，虽然这些设备并非真实存在RAM中 实验部分 Page Tables 检测被访问过的页面 背景：一些垃圾回收机制如果能够获取页面是否被访问的信息，将能够提高效率。 目的：实现检测页表访问位并将结果返回到用户态 预备知识 RISC-V硬件处理TLB缺失时，将新的虚拟地址载入时，会将相应的页面访问位置位 任务 代码实现在kernel/sysproc.c中的sys_pgaccess()，参数如下 第一个要检查的用户页面的虚拟地址 将要检查页面的数量 用于返回掩码结果的用户空间地址 使用argaddr()和argint()解析参数 最好在内核使用一个临时的缓冲区保存要输出的位掩码，利用copyout()输出 可以设置扫描页面数量的上限 使用walk()来找到正确的PTE 需要在kernel/riscv.h中定义PTE_A 确保检查PTE_A后，将其清零。否则无法判断在上次检查之后该页面有没有再次被访问 使用vmprint()来帮助debug 代码 Traps 帧指针、栈指针是函数调用的灵魂，栈指针负责为局部变量和参数分配空间，帧指针扮演寻找变量和参数的基石 内核堆栈和进程堆栈没有联系，只是他们都和进程一一对应 RISC-V汇编初识 目的：了解RISC-V中的汇编指令 预备知识：汇编语言 任务 编译fs.img，阅读call.asm中的g、f、main函数。回答以下问题并将答案编辑在answers-traps.txt文件之中 哪些寄存器保存传递给函数的参数，例如：当main函数调用printf函数时，哪个寄存器保存了13？ ，其中调用printf时，寄存器保存了13 在main函数的汇编码中，哪里调用了f，g这两个函数 函数 printf 位于什么地址？ 0x616，在RISCV指令中，auipc指令一般结合其他跳转指令来执行，因为在RISCV指令中无法表示32位的立即数，因此需要用auipc指令将一个20位立即数左移12位加上PC，存储在目的寄存器中。然后再由接下来的跳转指令用12位立即数填充低12位，最后实现跳转到PC附近的32位地址。这里的计算就是： 在 jalr 到 main 中的 printf 之后，寄存器 ra 中的值是什么？ 38，即当前地址+4 运行以下代码 unsigned int i = 0x00646c72; printf(&quot;H%x Wo%s&quot;, 57616, &amp;i); 请问输出是什么？(这段代码的输出依赖于RISC-V的小端模式)。若这段代码运行在大端模式的机器中，要使输出相同，应该给赋什么值？需要将57616改为其他值么？ 输出是Hell0 World，不用更改57616，只需要将0x00646c72改为0x726c6400 在这行代码中 printf(&quot;x=%d y=%d&quot;, 3); 后面会出现什么数字？(提示：这个数据不是某个特定的数字) 为什么会出现这种情况？ y后面的数字是随机的数字，取决于从栈帧中取到a2的垃圾数据 堆栈回溯 背景：在调试过程中，如果知道在出错点处的堆栈中存在哪些没有返回的函数调用是非常有帮助的 任务 在kernel/printf.c中实现backtrace()函数，并在sys_sleep中调用 在panic函数中调用backtrace，以便在系统崩溃时了解相关信息 代码 修改riscv.h // read the s0 register static inline uint64 r_fp() { uint64 x; asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) ); return x; } backtrace() void backtrace(void) { printf(&quot;backtrace: &quot;); uint64 fp = r_fp(); uint64 head = PGROUNDDOWN(fp); uint64 tail = PGROUNDUP(fp); uint64 ra; while((fp &gt;= head) &amp;&amp; fp &lt;= tail){ ra = *(uint64*)(fp - 8); fp = *(uint64*)(fp - 16); printf(&quot;%p &quot;, ra); } } panic(char* s) void panic(char *s) { pr.locking = 0; printf(&quot;panic: &quot;); printf(s); printf(&quot; &quot;); backtrace(); panicked = 1; // freeze uart output from other CPUs for(;;) ; } sys_sleep uint64 sys_sleep(void) { int n; uint ticks0; if(argint(0, &amp;n) &lt; 0) return -1; acquire(&amp;tickslock); ticks0 = ticks; while(ticks - ticks0 &lt; n){ if(myproc()-&gt;killed){ release(&amp;tickslock); return -1; } sleep(&amp;ticks, &amp;tickslock); } release(&amp;tickslock); backtrace(); return 0; } 闹钟 背景：计算密集型进程往往想知道自己消耗了多少时间，同时一些进程希望定期做某件任务 任务 实现一个用户级中断处理程序，sigalarm(interval, handler) 调用sigalarm(n, fn)的函数每经过n个CPU时钟，kernel就会调用fn，当fn返回后，进程恢复继续执行。(本质就是TRAP) 当应用调用sigalarm(0,0)时，kernel应该停止周期闹铃 在Makefile中添加alarmtest.c，同时在kernel添加sigalarm和sigturn user/alarmtest.asm或许对调试有所帮助 代码 修改Makefile ifeq ($(LAB),traps) UPROGS += \\ $U/_call\\ $U/_bttest\\ $U/_alarmtest endif 修改usys.pl entry(&quot;sigalarm&quot;); entry(&quot;sigreturn&quot;); 修改syscall.h #define SYS_sigalarm 22 #define SYS_sigreturn 23 修改syscall.c ... extern uint64 sys_sigalarm(void); extern uint64 sys_sigturn(void); static uint64 (*syscalls[])(void) = { ... [SYS_sigalarm] sys_sigalarm, [SYS_sigreturn] sys_sigreturn, } 修改proc.h struct proc { ... // these are private to the process, so p-&gt;lock need not be held. ... uint64 interval; // call handler for every interval ticks uint64 handler; // run every interval ticks uint64 count; // time left to call handler ... } 修改proc.c static struct proc* allocproc(void) { ... p-&gt;count = 0; ... } int sigalarm(uint64 interval, uint64 handler) { struct proc *p = myproc(); p-&gt;interval = interval; p-&gt;handler = handler; return 0; } 修改trap.c if(which_dev == 2){ if(++p-&gt;count &gt;= p-&gt;interval) { p-&gt;trapframe-&gt;epc = p-&gt;handler; p-&gt;count = 0; } yield(); } 修改sysproc.c uint64 sys_sigalarm(void) { uint64 interval; uint64 handler; if(argaddr(0, &amp;interval) &lt; 0) return -1; if(argaddr(1, &amp;handler) &lt; 0) return -1; return sigalarm(interval, handler); } Copy-on-Write 实现写时复制 背景：fork()将父进程的所有内存复制到子进程，如果父进程占用内存很大那么复制将会十分耗时，而且如果子进程在调用fork()后，直接调用exec()那么之前所做的复制都是无效的工作，这是对CPU资源的浪费。 任务 修改uvmcopy()将父进程的物理页面映射到子进程的页表之中。同时将父进程和子进程页表的PTE均设置为只读。 修改usertrap()识别COW页面的缺页异常，触发时通过kalloc()给子进程分配物理页面，并复制父进程内容，修改PTE_W 确保对没有被任何进程的页表所引用的页面进行回收。可以通过给每个物理页面记录一个reference count。当kalloc()时将reference count设置为1，当reference count为0时，调用kfree()回收页面。可以使用一个固定大小的整型数组，但是必须计算出合理的数组大小，并设计合理的索引方式。例如，你可以将物理页面地址除以4096作为索引，并通过最高的物理地址来计算出数组的大小。 修改copyout()进行复制，就像遇到缺页异常一样。 当一个COW页面发生缺页异常，如果此时没有多余的内存，那么选择将该进程杀死。 代码 *","tags":["系统学习","操作系统","国外课程"],"categories":["技术主线","操作系统"]},{"title":"Stanford CS144","path":"/2023/01/30/Stanford-CS144/","content":"RISCV Chapter 4 陷阱：三种强制CPU放弃执行当前指令而执行特殊代码的事件 系统调用：软中断 异常：零除；无效的虚拟地址 设备中断：比如磁盘完成读写 从陷阱退出后，应该恢复至发生陷阱前的状态 进入陷阱，强制进入kernel kernel保存当前运行状态 kernel执行中断处理代码 kernel用保存数据恢复状态 退出陷阱，继续正常执行代码 RISC-V trap mechinery","tags":["系统学习","国外课程","计算机网络"],"categories":["技术主线","计算机网络"]}]